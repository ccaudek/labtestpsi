{
  "hash": "c65d08e8ed513660fe93e055fe094b97",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  freeze: auto\n---\n\n\n\n\n\n# Distribuzioni di v.c. continue {#sec-prob-cont-prob-distr}\n\n\n**Prerequisiti**\n\n**Concetti e Competenze Chiave**\n\n**Preparazione del Notebook**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(mice)\n```\n:::\n\n\n\n\n\n## Introduzione\n\nAnalogamente a quanto avviene per le variabili casuali discrete, anche per le variabili casuali continue possiamo rappresentare la variabilità all'interno di una popolazione attraverso un modello statistico, ma in questo caso utilizziamo le densità di probabilità -- si veda il @sec-density-function. Mentre le distribuzioni di probabilità discrete si applicano a fenomeni con un numero finito o numerabile di esiti, le densità di probabilità sono fondamentali per descrivere variabili che possono assumere un continuum di valori.\n\nLa funzione di densità di probabilità $f(x)$ associata a una variabile casuale continua $X$ rappresenta la distribuzione della probabilità all'interno della popolazione. Questa funzione non fornisce la probabilità esatta di un singolo valore, ma piuttosto la probabilità di osservare valori di $X$ all'interno di un intervallo specifico. Così come per le distribuzioni discrete, anche le densità di probabilità costituiscono un modello della popolazione, una rappresentazione matematica che ci consente di fare previsioni e di comprendere meglio i fenomeni aleatori continui.\n\nIniziamo con la distribuzione continua uniforme.\n\n## Distribuzione Uniforme\n\nLa distribuzione uniforme è una delle più semplici funzioni di densità di probabilità. Consideriamo di nuovo l'esperimento dello spinner introdotto in precedenza. Simuliamo 20 valori che potrebbero essere ottenuti facendo ruotare lo spinner e li rappresentiamo con un istogramma.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulazione di 20 valori\nset.seed(123)\nspinner_results <- runif(20, min = 0, max = 360)\nprint(spinner_results)\n#>  [1] 103.5 283.8 147.2 317.9 338.6  16.4 190.1 321.3 198.5 164.4 344.5 163.2\n#> [13] 243.9 206.1  37.1 323.9  88.6  15.1 118.1 343.6\n\nggplot(data.frame(Valori = spinner_results), aes(x = Valori)) +\n  geom_histogram(binwidth = 10, fill = \"skyblue\", color = \"black\", alpha = 0.5) +\n  labs(x = \"Risultato dello spinner\", y = \"Frequenza relativa\",\n       title = \"Istogramma dei risultati (20 simulazioni)\") \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-2-1.png){width=576}\n:::\n:::\n\n\n\n\n\nNonostante possiamo pensare che ogni risultato tra 0 e 360 sia ugualmente probabile, l'istogramma non lo suggerisce chiaramente con solo 20 osservazioni. Simuliamo ora 100.000 ripetizioni.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulazione di 100.000 valori\nspinner_results_large <- runif(100000, min = 0, max = 360)\n\n# Istogramma\nggplot(data.frame(Valori = spinner_results_large), aes(x = Valori)) +\n  geom_histogram(binwidth = 10, fill = \"skyblue\", color = \"black\", alpha = 0.5) +\n  labs(x = \"Risultato dello spinner\", y = \"Frequenza relativa\",\n       title = \"Istogramma dei risultati (100.000 simulazioni)\") \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-3-1.png){width=576}\n:::\n:::\n\n\n\n\n\nIn questo caso, anche se ci sono variazioni nelle altezze delle barre (bin di ampiezza pari a 10), la forma generale dell'istogramma appare piuttosto uniforme su tutto l'intervallo $[0, 360]$. Con un numero enorme di risultati, l'istogramma si avvicinerebbe alla *funzione di densità uniforme* mostrata di seguito.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Curva della funzione di densità uniforme\nx <- seq(0, 360, length.out = 100)\ndensity_uniform <- dunif(x, min = 0, max = 360)\n\nggplot(data.frame(x = x, y = density_uniform), aes(x = x, y = y)) +\n  geom_line(size = 1, color = \"blue\") +\n  labs(x = \"x\", y = \"p(x)\", title = \"Funzione di densità uniforme\") \n#> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `linewidth` instead.\n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-4-1.png){width=576}\n:::\n:::\n\n\n\n\n\nQuando la variabile casuale $X$ è continua, come nel caso dello spinner, la probabilità è rappresentata da una curva, la *funzione di densità di probabilità*. Poiché lo spinner copre l'intervallo $[0, 360]$, la probabilità che $X$ sia compreso in questo intervallo è pari a 1. La densità costante è quindi:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 / 360\n#> [1] 0.00278\n```\n:::\n\n\n\n\n\n### Probabilità in un intervallo specifico\n\nLa probabilità di ottenere un valore tra 150 e 250, $P(150 < X < 250)$, è data dall'area sottesa alla curva in quell'intervallo. L'altezza della curva è $1/360$, mentre la base è $250 - 150 = 100$. Quindi:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n100 * (1 / 360)\n#> [1] 0.278\n```\n:::\n\n\n\n\n\nPer calcolare la probabilità, si possono utilizzare le funzioni di distribuzione cumulative:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunif(250, min = 0, max = 360) - punif(150, min = 0, max = 360)\n#> [1] 0.278\n```\n:::\n\n\n\n\n\nVisualizzazione dell'intervallo di probabilità:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizzazione della probabilità nell'intervallo [150, 250]\nx <- seq(0, 360, length.out = 1000)\nfx <- dunif(x, min = 0, max = 360)\n\nggplot(data.frame(x = x, fx = fx), aes(x = x, y = fx)) +\n  geom_line(size = 1, color = \"blue\") +\n  geom_area(data = subset(data.frame(x = x, fx = fx), x >= 150 & x <= 250),\n            aes(x = x, y = fx), fill = \"gray\", alpha = 0.5) +\n  labs(x = \"x\", y = \"p(x)\", title = \"Probabilità per l'intervallo [150, 250]\")\n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-8-1.png){width=576}\n:::\n:::\n\n\n\n\n\nIn maniera più formale possiamo dire che la distribuzione continua uniforme è una distribuzione di probabilità continua che assegna lo stesso grado di fiducia a tutti i possibili valori di una variabile definita in un certo intervallo $S=[a,b]\\subset {\\mathbb  {R}}$. La distribuzione continua uniforme viene indicata con ${\\mathcal  {U}}(a,b)={\\mathcal  {U}}([a,b])$. Come intervallo $[a,b]$ viene spesso preso l'intervallo unitario $I=[0,1]$.\n\nLa densità di probabilità di una variabile casuale continua uniforme ${\\mathcal  {U}}(a,b)$ è\n\n$$\nf(x)={\\frac  {1}{b-a}} \\quad \\text{su}\\; [a, b].\n$$\n\nIl suo valore attesto è\n\n$$\n\\displaystyle E(X)={\\frac {1}{2}}(b+a).\n$$\n\nLa sua varianza è\n\n$$\nV(X)={\\frac {1}{12}}(b-a)^{2}.\n$$\n\nIn R, è possibile manipolare la distribuzione uniforme utilizzando le funzioni della famiglia `runif`, `dunif`, `punif` e `qunif`. Di default, queste funzioni lavorano con la distribuzione uniforme standard $\\mathcal{U}(0,1)$. \n\n### Funzione di densità di probabilità (PDF)\n\nLa funzione `dunif()` calcola l'ordinata della funzione di densità per i valori di input specificati. Per esempio, esaminiamo la densità di $\\mathcal{U}(0,1)$ per i valori 0.5, 0.8 e 1.2. Ci aspettiamo di ottenere 1 per i primi due valori e 0 per 1.2, che è fuori dall'intervallo $[0, 1]$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunif(c(0.5, 0.8, 1.2), min = 0, max = 1)\n#> [1] 1 1 0\n```\n:::\n\n\n\n\n\n### Funzione di ripartizione (CDF)\n\nLa funzione `punif()` restituisce il valore della funzione di ripartizione. Per esempio, per $\\mathcal{U}(0,1)$ nei punti 0.5 e 0.8:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunif(c(0.5, 0.8), min = 0, max = 1)\n#> [1] 0.5 0.8\n```\n:::\n\n\n\n\n\n### Calcolo della probabilità in un intervallo\n\nUtilizzando la funzione di ripartizione, possiamo calcolare la probabilità che la variabile casuale continua assuma un valore in un intervallo specificato. Per esempio, per $\\mathcal{U}(0,1)$ troviamo $P(0.5 < X < 0.8)$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunif(0.8, min = 0, max = 1) - punif(0.5, min = 0, max = 1)\n#> [1] 0.3\n```\n:::\n\n\n\n\n\n### Calcolo dei quantili\n\nLa funzione `qunif()` restituisce i quantili della distribuzione uniforme, ovvero il valore della variabile casuale $X$ in corrispondenza del valore della funzione di ripartizione fornito in input. Per esempio, troviamo i quantili di ordine 0.5 e 0.8 di $\\mathcal{U}(0,1)$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqunif(c(0.5, 0.8), min = 0, max = 1)\n#> [1] 0.5 0.8\n```\n:::\n\n\n\n\n\n### Simulazione di valori casuali\n\nLa funzione `runif()` consente di generare numeri casuali dalla distribuzione uniforme. Per esempio, simuliamo 5 valori casuali da $\\mathcal{U}(0,1)$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Per la riproducibilità\nrunif(5, min = 0, max = 1)\n#> [1] 0.288 0.788 0.409 0.883 0.940\n```\n:::\n\n\n\n\n\n### Valore atteso\n\nPer verificare il valore atteso di 100,000 realizzazioni di $\\mathcal{U}(0,1)$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(runif(100000, min = 0, max = 1))\n#> [1] 0.499\n```\n:::\n\n\n\n\n\n### Varianza\n\nPer calcolare la varianza di 100,000 realizzazioni di $\\mathcal{U}(0,1)$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(runif(100000, min = 0, max = 1))\n#> [1] 0.0834\n```\n:::\n\n\n\n\n\nConfrontiamo il valore teorico della varianza per $\\mathcal{U}(0,1)$, che è $1/12$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 / 12\n#> [1] 0.0833\n```\n:::\n\n\n\n\n\nIn conclusione, le funzioni della famiglia `runif`, `dunif`, `punif` e `qunif` in R consentono di manipolare e analizzare la distribuzione uniforme.\n\n## Distribuzione Gaussiana\n\nLa più importante distribuzione di densità è la Gaussiana. Non c'è un'unica distribuzione gaussiana (o Normale): la distribuzione gaussiana è una famiglia di distribuzioni. Tali distribuzioni sono dette \"gaussiane\" in onore di Carl Friedrich Gauss (uno dei più grandi matematici della storia il quale, tra le altre cose, scoprì l'utilità di tale funzione di densità per descrivere gli errori di misurazione). Adolphe Quetelet, il padre delle scienze sociali quantitative, fu il primo ad applicare tale funzione di densità alle misurazioni dell'uomo. Karl Pearson usò per primo il termine \"distribuzione normale\" anche se ammise che questa espressione \"ha lo svantaggio di indurre le persone a credere che le altre distribuzioni, in un senso o nell'altro, non siano normali.\"\n\n### Limite delle distribuzioni binomiali\n\nIniziamo con un un breve excursus storico. Nel 1733, Abraham de Moivre notò che, aumentando il numero di prove di una distribuzione binomiale, la distribuzione risultante diventava quasi simmetrica e a forma campanulare. Per esempio, con 10 prove e una probabilità di successo di 0.9, la distribuzione è chiaramente asimmetrica.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parametri\nn <- 10\np <- 0.9\n\n# Calcolare la distribuzione binomiale\nr_values <- 0:n\ndist <- dbinom(r_values, size = n, prob = p)\n\n# Grafico\nggplot(data.frame(Successi = r_values, Probabilità = dist), aes(x = Successi, y = Probabilità)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\", color = \"black\") +\n  labs(title = \"Distribuzione Binomiale: n = 10, p = 0.9\", x = \"Numero di Successi\", y = \"Probabilità\") \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-17-1.png){width=576}\n:::\n:::\n\n\n\n\n\nQuando il numero di prove *N* viene aumentato di un fattore di 100 a *N* = 1000, mantenendo costante la probabilità di successo del 90%, si osserva che la distribuzione assume una forma campanulare quasi simmetrica. Questa osservazione porta a una scoperta di de Moivre: quando *N* diventa grande, la funzione gaussiana, nonostante rappresenti la densità di variabili casuali continue, offre una buona approssimazione alla funzione di massa di probabilità binomiale.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parametri aggiornati\nn <- 1000\n\n# Calcolare la distribuzione\nr_values <- 850:950  # Intervallo per una migliore visualizzazione\ndist <- dbinom(r_values, size = n, prob = p)\n\n# Grafico\nggplot(data.frame(Successi = r_values, Probabilità = dist), aes(x = Successi, y = Probabilità)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\", color = \"black\") +\n  labs(\n    title = \"Distribuzione Binomiale: n = 1000, p = 0.9\", \n    x = \"Numero di Successi\", \n    y = \"Probabilità\"\n  ) \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-18-1.png){width=576}\n:::\n:::\n\n\n\n\n\nLa distribuzione Normale fu scoperta da Gauss nel 1809. Il Paragrafo successivo illustra come si possa giungere alla Normale mediante una simulazione.\n\n### La Normale prodotta con una simulazione\n\nIl libro \"Rethinking Statistics\" di @McElreath_rethinking spiega come sia possibile ottenere la distribuzione normale attraverso una simulazione. Immaginiamo di avere duemila persone che si trovano allineate su una linea di partenza. Quando viene dato il segnale di partenza, ogni persona lancia una moneta e compie un passo avanti o indietro a seconda del risultato del lancio. La lunghezza di ogni passo può variare da 0 a 1 metro. Ogni persona lancia la moneta 16 volte e quindi compie 16 passi.\n\nI risultati ottenuti da una serie di passeggiate casuali si traducono in varie distanze dall'origine, che è il punto da cui si parte, contrassegnato come zero, dopo un numero specificato di passi. Queste distanze sono rappresentate numericamente. Al termine di queste passeggiate, non è possibile determinare la posizione esatta di ogni individuo, ma è possibile descrivere accuratamente le caratteristiche della distribuzione delle 1000 distanze dall'origine.\n\nAd esempio, è possibile prevedere con precisione la frazione di individui che si sono mossi verso in avanti o indietro, o la proporzione di persone che si troveranno a una distanza specifica dal punto di partenza, come a 1.5 metri dall'origine. Queste previsioni sono fattibili perché la distribuzione delle distanze segue una distribuzione Normale.\n\nIl codice presentato di seguito genera passeggiate casuali utilizzando un generatore di numeri casuali e ne traccia i percorsi risultanti. Il codice inizia inizializzando un oggetto generatore di numeri casuali con la funzione `np.random.default_rng()` della libreria `numpy`. Questo generatore sarà usato per produrre numeri casuali uniformemente distribuiti tra -1 e 1, simulando così il lancio di una moneta.\n\nLa variabile `steps` specifica il numero di passi per ogni passeggiata casuale, mentre `repetitions` indica il numero di passeggiate da generare. La variabile `show_steps` è un elenco di numeri di passi in cui il codice traccerà linee verticali sul grafico.\n\nSuccessivamente, il codice crea un array bidimensionale di NumPy chiamato `x` con righe pari a `steps + 1` e colonne pari a `repetitions`. La prima colonna di questo array è riempita di zeri, e le colonne rimanenti sono riempite con la somma cumulativa dei passi, ottenuti da numeri casuali uniformemente distribuiti generati dal generatore di numeri casuali. Questo array verrà utilizzato per memorizzare le posizioni della passeggiata casuale ad ogni passo.\n\nIl codice poi prepara una figura per tracciare tutte le passeggiate casuali. Il codice traccia anche la prima passeggiata casuale in nero.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parametri\nnumero_passi <- 16\nripetizioni <- 1000\npunti_da_evidenziare <- c(4, 8, 16)\n\n# Generare passeggiate casuali\nset.seed(123)\nx <- matrix(0, nrow = numero_passi + 1, ncol = ripetizioni)\n\nfor (i in 1:ripetizioni) {\n  passi <- runif(numero_passi, min = -1, max = 1)\n  x[-1, i] <- cumsum(passi)\n}\n\n# Grafico delle passeggiate casuali\ndf <- data.frame(\n  Passo = rep(0:numero_passi, times = ripetizioni), \n  Distanza = as.vector(x)\n)\n\n# Grafico delle passeggiate casuali\nggplot(\n  df, \n  aes(\n    x = Passo, \n    y = Distanza, \n    group = rep(1:ripetizioni, each = numero_passi + 1))\n  ) +\n  geom_line(color = \"blue\", alpha = 0.05) +\n  geom_line(\n    data = data.frame(Passo = 0:numero_passi, Distanza = x[, 1], group = 1), \n    aes(x = Passo, y = Distanza, group = group), color = \"black\") +\n  geom_vline(\n    xintercept = punti_da_evidenziare, \n    linetype = \"dashed\", \n    color = \"black\", \n    alpha = 0.5) +\n  labs(\n    title = \"Passeggiate Casuali\", \n    x = \"Numero di Passi\", \n    y = \"Distanza dall'Origine\"\n  ) \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-19-1.png){width=576}\n:::\n:::\n\n\n\n\n\nIl grafico riportato qui sotto visualizza la distribuzione dei passi a partire dalla linea mediana dopo 4, 8 e 16 lanci di moneta/passi. Quello che si nota è che, man mano che procediamo nel numero di passi, le densità iniziano a somigliare alla curva a campana associata alle distribuzioni Gaussiane.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensities <- lapply(punti_da_evidenziare, function(step) {\n  data.frame(Posizione = x[step + 1, ], Passo = step)\n})\n\ndensities <- bind_rows(densities)\n\nggplot(densities, aes(x = Posizione, fill = as.factor(Passo))) +\n  geom_density(alpha = 0.6) +\n  facet_wrap(~ Passo, scales = \"free\") +\n  labs(\n    title = \"Densità delle Posizioni\",\n    x = \"Posizione\",\n    y = \"Densità\",\n    fill = \"Passo\"  # Etichetta per la legenda\n  ) +\n  theme(\n    legend.position = \"bottom\"  # Sposta la legenda in basso\n  )\n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-20-1.png){width=576}\n:::\n:::\n\n\n\n\n\nLa chiarezza dell'informazione presentata nei grafici precedenti può essere migliorata utilizzando un KDE plot.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generare i dati\nposizioni <- apply(matrix(runif(numero_passi * ripetizioni, min = -1, max = 1), nrow = numero_passi), 2, sum)\n\n# Calcolare media e deviazione standard\nmedia <- mean(posizioni)\ndev_std <- sd(posizioni)\n\n# Generare la curva normale\nvalori <- seq(min(posizioni), max(posizioni), length.out = 1000)\ndensità_normale <- dnorm(valori, mean = media, sd = dev_std)\n\n# Grafico\nggplot(data.frame(Posizione = posizioni), aes(x = Posizione)) +\n  geom_density(fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = data.frame(Posizione = valori, Densità = densità_normale), aes(x = Posizione, y = Densità), color = \"red\", linetype = \"dashed\") +\n  labs(title = \"Confronto tra Passeggiate Casuali e Normale\", x = \"Posizione\", y = \"Densità\") \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-21-1.png){width=576}\n:::\n:::\n\n\n\n\n\nQuesta simulazione in luce un principio fondamentale della teoria delle probabilità: ogni processo che coinvolge la somma di una sequenza di valori casuali, tutti estratti dalla stessa distribuzione, inevitabilmente tende verso una distribuzione normale, comunemente conosciuta come curva gaussiana. Questa tendenza si verifica indipendentemente dalla configurazione iniziale della distribuzione di partenza, che può essere uniforme, come nell'esempio menzionato, o di qualsiasi altro tipo. La forma specifica della distribuzione iniziale influisce sulla velocità con cui si verifica questa convergenza verso il comportamento gaussiano, con variazioni significative nella velocità di convergenza: alcuni processi possono manifestare una convergenza lenta, mentre altri possono convergere estremamente rapidamente. Un esempio emblematico di questo fenomeno è rappresentato dal dispositivo conosciuto come [Galton box](https://en.wikipedia.org/wiki/Galton_board), il quale offre una rappresentazione visiva e fisica di come la somma di valori casuali generi una distribuzione normale.\n\nUn modo per razionalizzare la distribuzione Gaussiana è quello di pensare alle medie. Qualunque sia il valore medio della distribuzione di origine, ogni campione da essa può essere considerato una fluttuazione rispetto a quel valore medio. Tuttavia, quando sommiamo queste fluttuazioni insieme, esse si annullano a vicenda. E, facendo ciò, queste fluttuazioni convergono eventualmente alla media delle osservazioni collettive. Non importa quale sia la forma della distribuzione sottostante. A seconda della forma, le somme cumulative convergeranno inevitabilmente sulla media, alcune distribuzioni più lentamente di altre.\n\nDal punto di vista formale, possiamo definire una variabile casuale continua $Y$ come avente una distribuzione normale se la sua densità di probabilità è distribuita secondo la seguente equazione\n\n$$\nf(y; \\mu, \\sigma) = {1 \\over {\\sigma\\sqrt{2\\pi} }} \\exp \\left\\{-\\frac{(y -  \\mu)^2}{2 \\sigma^2} \\right\\},\n$$ {#eq-normal-formula}\n\ndove $\\mu \\in \\mathbb{R}$ e $\\sigma > 0$ sono i parametri della distribuzione.\n\nLa densità normale è unimodale e simmetrica con una caratteristica forma a campana e con il punto di massima densità in corrispondenza di $\\mu$.\n\nIl significato dei parametri $\\mu$ e $\\sigma$ che appaiono nell'eq. {eq}`eq-normal-formula` viene chiarito dalla dimostrazione che\n\n$$\n\\mathbb{E}(Y) = \\mu, \\qquad \\mathbb{V}(Y) = \\sigma^2.\n$$\n\nLa rappresentazione grafica di quattro densità Normali con medie -1, -0.5, 0, 1 e con deviazioni standard 0.25, 0.5, 1 e 2 è fornita nella figura seguente.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definire l'intervallo di x\nx <- seq(-5, 6, by = 0.001)\n\n# Parametri della distribuzione normale\nmus <- c(-1.0, -0.5, 0.0, 1.0)\nsigmas <- c(0.25, 0.5, 1, 2)\n\n# Creare un data frame per tutte le combinazioni di mu e sigma\ndata <- do.call(rbind, lapply(1:length(mus), function(i) {\n  data.frame(\n    x = x,\n    f_x = dnorm(x, mean = mus[i], sd = sigmas[i]),\n    mu = mus[i],\n    sigma = sigmas[i]\n  )\n}))\n\n# Grafico\nggplot(data, aes(x = x, y = f_x, color = factor(mu), linetype = factor(sigma))) +\n  geom_line(size = 1) +\n  labs(\n    x = \"x\",\n    y = \"f(x)\",\n    color = expression(mu),\n    linetype = expression(sigma),\n    title = \"Distribuzioni Normali con Diversi Parametri\"\n  ) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-22-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### Concentrazione\n\nÈ istruttivo osservare il grado di concentrazione della distribuzione Normale attorno alla media:\n\n$$\n\\begin{align}\nP(\\mu - \\sigma < Y < \\mu + \\sigma) &= P (-1 < Z < 1) \\simeq 0.683, \\notag\\\\\nP(\\mu - 2\\sigma < Y < \\mu + 2\\sigma) &= P (-2 < Z < 2) \\simeq 0.956, \\notag\\\\\nP(\\mu - 3\\sigma < Y < \\mu + 3\\sigma) &= P (-3 < Z < 3) \\simeq 0.997. \\notag\n\\end{align}\n$$\n\nSi noti come un dato la cui distanza dalla media è superiore a 3 volte la deviazione standard presenti un carattere di eccezionalità perché meno del 0.3% dei dati della distribuzione Normale presentano questa caratteristica.\n\nPer indicare la distribuzione Normale si usa la notazione $\\mathcal{N}(\\mu, \\sigma)$.\n\n### Funzione di ripartizione\n\nIl valore della funzione di ripartizione di $Y$ nel punto $y$ è l'area sottesa alla curva di densità $f(y)$ nella semiretta $(-\\infty, y]$. Non esiste alcuna funzione elementare per la funzione di ripartizione\n\n$$\nF(y) = \\int_{-\\infty}^y {1 \\over {\\sigma\\sqrt{2\\pi} }} \\exp \\left\\{-\\frac{(y - \\mu)^2}{2\\sigma^2} \\right\\} dy, \n$$ (eq-gaussian-rip-formula)\n\npertanto le probabilità $P(Y < y)$ vengono calcolate mediante integrazione numerica approssimata. I valori della funzione di ripartizione di una variabile casuale Normale sono dunque forniti da un software.\n\nEcco l'equivalente in R utilizzando le funzioni per la distribuzione normale e il pacchetto `ggplot2` per i grafici.\n\n### Generazione di Valori Casuali\n\nIn R, la funzione `rnorm()` genera valori casuali dalla distribuzione normale. Ad esempio, per ottenere un singolo valore casuale dalla $\\mathcal{N}(100, 15)$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generare un singolo valore casuale\nset.seed(123)  # Per la riproducibilità\nrnorm(1, mean = 100, sd = 15)\n#> [1] 91.6\n```\n:::\n\n\n\n\n\nPer estrarre 10 valori casuali dalla stessa distribuzione:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generare 10 valori casuali\nset.seed(123)\nqi <- rnorm(10, mean = 100, sd = 15)\nprint(qi)\n#>  [1]  91.6  96.5 123.4 101.1 101.9 125.7 106.9  81.0  89.7  93.3\n```\n:::\n\n\n\n\n\n### Funzione di Ripartizione (CDF)\n\nPer calcolare la probabilità che un'osservazione casuale abbia un valore minore o uguale a 115, utilizziamo `pnorm()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Probabilità che X <= 115\npnorm(115, mean = 100, sd = 15)\n#> [1] 0.841\n```\n:::\n\n\n\n\n\n### Visualizzazione dell'Area Sottesa alla Funzione di Densità\n\nPossiamo visualizzare l'area sottesa utilizzando `ggplot2`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parametri\nmu <- 100\nsigma <- 15\n\n# Intervallo di x\nx <- seq(mu - 3 * sigma, mu + 3 * sigma, length.out = 1000)\n\n# Densità\nfx <- dnorm(x, mean = mu, sd = sigma)\n\n# Grafico\nggplot(data.frame(x, fx), aes(x = x, y = fx)) +\n  geom_line(color = \"blue\") +\n  geom_area(\n    data = subset(data.frame(x, fx), x <= 115), \n    aes(x = x, y = fx), fill = \"gray\", alpha = 0.5\n  ) +\n  labs(title = \"Funzione di Densità Normale\", x = \"x\", y = \"f(x)\") \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-26-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### Calcolo dell'Integrale con `integrate`\n\nPossiamo calcolare l'area sotto la curva manualmente utilizzando la funzione `integrate`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definizione della funzione gaussiana\ngaussian <- function(x, mu, sigma) {\n  (1 / (sqrt(2 * pi) * sigma)) * exp(-((x - mu)^2) / (2 * sigma^2))\n}\n\n# Calcolo dell'area\nresult <- integrate(gaussian, lower = -Inf, upper = 115, mu = 100, sigma = 15)\nprint(paste(\"Il risultato è\", result$value, \"con errore\", result$abs.error))\n#> [1] \"Il risultato è 0.84134474610298 con errore 3.76616994661114e-06\"\n```\n:::\n\n\n\n\n\n### Proporzione di Valori Maggiori di 130\n\nCalcoliamo $P(X > 130)$ utilizzando il complementare della funzione di ripartizione:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Probabilità che X > 130\n1 - pnorm(130, mean = 100, sd = 15)\n#> [1] 0.0228\n```\n:::\n\n\n\n\n\nPossiamo anche utilizzare la funzione di sopravvivenza `1 - pnorm()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funzione di sopravvivenza\npnorm(130, mean = 100, sd = 15, lower.tail = FALSE)\n#> [1] 0.0228\n```\n:::\n\n\n\n\n\nVisualizzazione:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data.frame(x, fx), aes(x = x, y = fx)) +\n  geom_line(color = \"blue\") +\n  geom_area(\n    data = subset(data.frame(x, fx), x >= 130), \n    aes(x = x, y = fx), fill = \"gray\", alpha = 0.5\n  ) +\n  labs(title = \"Area Sottesa per X >= 130\", x = \"x\", y = \"f(x)\") \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-30-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### Funzione di Quantile (PPF)\n\nLa funzione `qnorm()` restituisce il quantile della distribuzione normale. Ad esempio:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Quantile corrispondente al 97.725%\nqnorm(1 - 0.022750131948179195, mean = 100, sd = 15)\n#> [1] 130\n```\n:::\n\n\n\n\n\nIn conclusione, le funzioni `rnorm`, `dnorm`, `pnorm`, e `qnorm` in R forniscono gli strumenti necessari per manipolare la distribuzione normale.\n\n### Distribuzione Normale standard\n\nLa distribuzione Normale di parametri $\\mu = 0$ e $\\sigma = 1$ viene detta *distribuzione Normale standard*. La famiglia Normale è l'insieme avente come elementi tutte le distribuzioni Normali con parametri $\\mu$ e $\\sigma$ diversi. Tutte le distribuzioni Normali si ottengono dalla Normale standard mediante una trasformazione lineare: se $Y \\sim \\mathcal{N}(\\mu_Y, \\sigma_Y)$ allora\n\n$$\nX = a + b Y \\sim \\mathcal{N}(\\mu_X = a+b \\mu_Y, \\sigma_X = \\left|b\\right|\\sigma_Y).\n$$\n\nL'area sottesa alla curva di densità di $\\mathcal{N}(\\mu, \\sigma)$ nella semiretta $(-\\infty, y]$ è uguale all'area sottesa alla densità Normale standard nella semiretta $(-\\infty, z]$, in cui $z = (y -\\mu_Y )/\\sigma_Y$ è il punteggio standard di $Y$. Per la simmetria della distribuzione, l'area sottesa nella semiretta $[1, \\infty)$ è uguale all'area sottesa nella semiretta $(-\\infty, 1]$ e quest'ultima coincide con $F(-1)$. Analogamente, l'area sottesa nell'intervallo $[y_a, y_b]$, con $y_a < y_b$, è pari a $F(z_b) - F(z_a)$, dove $z_a$ e $z_b$ sono i punteggi standard di $y_a$ e $y_b$.\n\nSi ha anche il problema inverso rispetto a quello del calcolo delle aree: dato un numero $0 \\leq p \\leq 1$, il problema è quello di determinare un numero $z \\in \\mathbb{R}$ tale che $P(Z < z) = p$. Il valore $z$ cercato è detto *quantile* di ordine $p$ della Normale standard e può essere trovato mediante un software.\n\nSupponiamo che l'altezza degli individui adulti segua la distribuzione Normale di media $\\mu = 1.7$ m e deviazione standard $\\sigma = 0.1$ m. Vogliamo sapere la proporzione di individui adulti con un'altezza compresa tra $1.7$ e $1.8$ m.\n\nIl problema ci chiede di trovare l'area sottesa alla distribuzione $\\mathcal{N}(\\mu = 1.7, \\sigma = 0.1)$ nell'intervallo $[1.7, 1.8]$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parametri della distribuzione\nmu <- 1.7\nsigma <- 0.1\n\n# Calcolare la probabilità cumulativa\nprob <- pnorm(1.8, mean = mu, sd = sigma) - pnorm(1.7, mean = mu, sd = sigma)\nprint(prob)\n#> [1] 0.341\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generare dati\nx <- seq(mu - 3 * sigma, mu + 3 * sigma, length.out = 1000)\nfx <- dnorm(x, mean = mu, sd = sigma)\n\n# Creare il grafico\nggplot(data.frame(x, fx), aes(x = x, y = fx)) +\n  geom_line(color = \"blue\") +\n  geom_area(data = subset(data.frame(x, fx), x >= 1.7 & x <= 1.8), \n            aes(x = x, y = fx), fill = \"gray\", alpha = 0.5) +\n  labs(title = \"Funzione di Densità Normale\", \n       x = \"Altezza (m)\", \n       y = \"Densità\")\n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-33-1.png){width=576}\n:::\n:::\n\n\n\n\n\nIn maniera equivalente, possiamo standardizzare i valori che delimitano l'intervallo considerato e utilizzare la funzione di ripartizione della normale standardizzata. I limiti inferiore e superiore dell'intervallo sono\n\n$$\nz_{\\text{inf}} = \\frac{1.7 - 1.7}{0.1} = 0, \\quad z_{\\text{sup}} = \\frac{1.8 - 1.7}{0.1} = 1.0,\n$$\n\nquindi otteniamo\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Standardizzazione\nz_inf <- (1.7 - mu) / sigma\nz_sup <- (1.8 - mu) / sigma\n\n# Calcolo con la normale standardizzata\nprob_standard <- pnorm(z_sup, mean = 0, sd = 1) - pnorm(z_inf, mean = 0, sd = 1)\nprint(prob_standard)\n#> [1] 0.341\n```\n:::\n\n\n\n\n\nIl modo più semplice per risolvere questo problema resta comunque quello di rendersi conto che la probabilità richiesta non è altro che la metà dell'area sottesa dalle distribuzioni Normali nell'intervallo $[\\mu - \\sigma, \\mu + \\sigma]$, ovvero $0.683/2$.\n\nConsideriamo ora la visualizzazione della PDF, la CDF e l'inverso della CDF della distribuzione normale.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parametri della distribuzione\nmu <- 100\nsigma <- 15\n\n# Generare intervalli di valori\nx <- seq(mu - 3 * sigma, mu + 3 * sigma, length.out = 1000)\nprobabilities <- seq(0.01, 0.99, length.out = 100)\n\n# Calcolo delle funzioni\npdf <- dnorm(x, mean = mu, sd = sigma)\ncdf <- pnorm(x, mean = mu, sd = sigma)\nppf <- qnorm(probabilities, mean = mu, sd = sigma)\n\n# Creare i grafici con ggplot2\nlibrary(gridExtra)\n\n# Grafico della PDF\npdf_plot <- ggplot(data.frame(x, pdf), aes(x = x, y = pdf)) +\n  geom_line(color = \"blue\") +\n  labs(title = \"PDF\", x = \"Valori\", y = \"Probabilità\")\n\n# Grafico della CDF\ncdf_plot <- ggplot(data.frame(x, cdf), aes(x = x, y = cdf)) +\n  geom_line(color = \"orange\") +\n  labs(title = \"CDF\", x = \"Valori\", y = \"Cumulativa\")\n\n# Grafico dell'inversa della CDF\nppf_plot <- ggplot(data.frame(Probabilità = probabilities, Valori = ppf), aes(x = Probabilità, y = Valori)) +\n  geom_line(color = \"green\") +\n  labs(title = \"Inverse CDF\", x = \"Probabilità\", y = \"Valori\") \n\n# Mostrare i grafici\ngrid.arrange(pdf_plot, cdf_plot, ppf_plot, ncol = 3)\n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-35-1.png){width=576}\n:::\n:::\n\n\n\n\n\nDovrebbe essere chiaro dalla figura che queste sono tre diverse modalità di osservare la stessa informazione.\n\n## Distribuzione Chi-quadrato\n\nDalla Normale deriva la distribuzione $\\chi^2$. La distribuzione $\\chi^2_{~k}$ con $k$ gradi di libertà descrive la variabile casuale\n\n$$\nZ_1^2 + Z_2^2 + \\dots + Z_k^2,\n$$\n\ndove $Z_1, Z_2, \\dots, Z_k$ sono variabili casuali i.i.d. che seguono la distribuzione Normale standard $\\mathcal{N}(0, 1)$. La variabile casuale chi-quadrato dipende dal parametro intero positivo $\\nu = k$ che ne identifica il numero di gradi di libertà. La densità di probabilità di $\\chi^2_{~\\nu}$ è\n\n$$\nf(x) = C_{\\nu} x^{\\nu/2-1} \\exp (-x/2), \\qquad \\text{se } x > 0,\n$$\n\ndove $C_{\\nu}$ è una costante positiva.\n\n### Grafico delle Distribuzioni Chi-Quadrato per Vari Valori di $\\nu$\n\nIn R, utilizziamo `dchisq()` per calcolare la funzione di densità della distribuzione chi-quadrato e `ggplot2` per creare il grafico.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Intervallo di x\nx <- seq(0, 40, by = 0.1)\n\n# Valori di gradi di libertà\nnus <- c(2, 4, 8, 16)\n\n# Creazione del data frame per il grafico\ndata <- do.call(rbind, lapply(nus, function(nu) {\n  data.frame(x = x, f_x = dchisq(x, df = nu), nu = as.factor(nu))\n}))\n\n# Grafico\nggplot(data, aes(x = x, y = f_x, color = nu)) +\n  geom_line(size = 1) +\n  labs(\n    title = \"Distribuzioni Chi-Quadrato per Diversi Valori di \\u03bd\",\n    x = \"x\",\n    y = \"f(x)\",\n    color = expression(nu)\n  ) \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-36-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### Proprietà della Distribuzione Chi-Quadrato\n\n1. **Asimmetria**: La distribuzione $\\chi^2_{\\nu}$ è asimmetrica.\n2. **Media**: Il valore atteso di una variabile $\\chi^2_{\\nu}$ è uguale a $\\nu$.\n3. **Varianza**: La varianza è pari a $2\\nu$.\n4. **Convergenza**: Per $k \\to \\infty$, $\\chi^2_{\\nu} \\to \\mathcal{N}(\\nu, 2\\nu)$.\n5. **Somma di variabili**: La somma di variabili $\\chi^2_{\\nu}$ indipendenti con gradi di libertà diversi segue una distribuzione $\\chi^2_{m}$, dove $m$ è la somma dei gradi di libertà.\n\n### Esempio con $\\chi^2_5$\n\nDensità della Distribuzione $\\chi^2_5$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parametri\ndf <- 5\nx <- seq(0, 20, length.out = 200)\n\n# Calcolare la densità\npdf <- dchisq(x, df = df)\n\n# Grafico\nggplot(data.frame(x, pdf), aes(x = x, y = pdf)) +\n  geom_line(color = \"blue\", size = 1) +\n  labs(\n    title = \"Distribuzione Chi-Quadrato (\\u03bd=5)\",\n    x = \"x\",\n    y = \"PDF\"\n  ) \n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-37-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### Generazione di Valori Casuali\n\nIn R, utilizziamo `rchisq()` per generare valori casuali dalla distribuzione chi-quadrato.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generare 1.000.000 di valori casuali\nset.seed(123)  # Per riproducibilità\nx_samples <- rchisq(1000000, df = df)\n\n# Mostrare i primi 20 valori\nhead(x_samples, 20)\n#>  [1]  2.572  8.075  0.649  4.374 10.322  5.410  1.222  0.606  8.211  5.082\n#> [11]  5.214  4.319  2.582  8.500  6.676  3.844  2.775  3.413  1.624  3.762\n```\n:::\n\n\n\n\n\n### Calcolo della Media\n\nLa media teorica della distribuzione chi-quadrato è uguale a $\\nu$. Verifichiamo empiricamente:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcolare la media\nmean(x_samples)\n#> [1] 5\n```\n:::\n\n\n\n\n\n### Calcolo della Varianza\n\nLa varianza teorica della distribuzione chi-quadrato è $2\\nu$. Verifichiamo empiricamente:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcolare la varianza\nvar(x_samples)\n#> [1] 9.99\n```\n:::\n\n\n\n\n\nIn conclusione,\n\n- la distribuzione chi-quadrato è asimmetrica e converge alla distribuzione normale per valori elevati di $\\nu$,\n- la media e la varianza empiriche dei valori generati sono vicine ai valori teorici, verificando le proprietà della distribuzione.\n\n\n## Distribuzione $t$ di Student\n\nDalle distribuzioni Normale e Chi-quadrato deriva un'altra distribuzione molto nota, la $t$ di Student. Se $Z \\sim \\mathcal{N}(0, 1)$ e $W \\sim \\chi^2_{\\nu}$ sono due variabili casuali indipendenti, allora il rapporto\n\n$$\nT = \\frac{Z}{\\Big( \\frac{W}{\\nu}\\Big)^{\\frac{1}{2}}}\n$$\n\ndefinisce la distribuzione $t$ di Student con $\\nu$ gradi di libertà. Si usa scrivere $T \\sim t_{\\nu}$. L'andamento della distribuzione $t$ di Student è simile a quello della distribuzione Normale, ma ha una dispersione maggiore (ha le code più pesanti di una Normale, ovvero ha una varianza maggiore di 1).\n\nLa seguente mostra alcune distribuzioni $t$ di Student variando il parametro $\\nu$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(-5, 5, by = 0.1)\nnus <- c(1, 2, 5, 30)\n\ndf <- data.frame(\n  x = rep(x, length(nus) + 1),\n  density = c(\n    sapply(nus, function(nu) dt(x, df = nu)), dnorm(x, mean = 0, sd = 1)\n  ),\n  distribution = factor(\n    rep(c(paste0(\"t (ν = \", nus, \")\"), \"N(μ = 0, σ = 1)\"), each = length(x))\n  )\n)\n\nggplot(df, aes(x = x, y = density, color = distribution)) +\n  geom_line(size = 1) +\n  labs(\n    x = \"x\", \n    y = \"f(x)\", \n    title = \"Distribuzione t di Student e Normale\"\n  ) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](12_cont_rv_distr_files/figure-html/unnamed-chunk-41-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### Proprietà\n\nLa variabile casuale $t$ di Student soddisfa le seguenti proprietà:\n\n1.  Per $\\nu \\rightarrow \\infty$, $t_{\\nu}$ tende alla normale standard $\\mathcal{N}(0, 1)$.\n2.  La densità della $t_{\\nu}$ è una funzione simmetrica con valore atteso nullo.\n3.  Per $\\nu > 2$, la varianza della $t_{\\nu}$ vale $\\nu / (\\nu - 2)$; pertanto è sempre maggiore di 1 e tende a 1 per $\\nu \\rightarrow \\infty$.\n\nCalcoliamo il valore della funzione di ripartizione di ordine 0.025 nel caso di una $t_{30}$:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqt(0.025, df = 30)\n#> [1] -2.04\n```\n:::\n\n\n\n\n\nAumentiamo i gradi di libertà ($\\nu$ = 1000):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqt(0.025, df = 1000)\n#> [1] -1.96\n```\n:::\n\n\n\n\n\nQuesto valore è quasi identico a quello della Normale standardizzata:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(0.025, mean = 0, sd = 1)\n#> [1] -1.96\n```\n:::\n\n\n\n\n\nLa ragione per cui il quantile della distribuzione $t$ con $\\nu = 30$ è maggiore (in valore assoluto) del quantile omotetico della distribuzione Normale Standard è che la distribuzione $t$ ha una varianza maggiore rispetto alla distribuzione Normale Standard.\n\n\n## Generazione di Campioni\n\nIn R, possiamo generare campioni da diverse distribuzioni utilizzando le funzioni `rnorm`, `runif` e `rt`. Ad esempio:\n\n**Distribuzione Normale**:\n```r\nset.seed(42)  # Per garantire la riproducibilità\nmedia <- 0\ndeviazione_standard <- 1\ncampione_normale <- rnorm(100, mean = media, sd = deviazione_standard)\n```\n\n**Distribuzione Uniforme**:\n```r\na <- 0\nb <- 10\ncampione_uniforme <- runif(100, min = a, max = b)\n```\n\n**Distribuzione t di Student**:\n```r\ngradi_libertà <- 10\ncampione_t <- rt(100, df = gradi_libertà)\n```\n\n---\n\n#### Calcolo della Densità\n\nPossiamo calcolare la densità utilizzando le funzioni `dnorm`, `dunif` e `dt`. Ad esempio:\n\n**Distribuzione Normale**:\n```r\nx <- seq(media - 4 * deviazione_standard, media + 4 * deviazione_standard, length.out = 100)\npdf_normale <- dnorm(x, mean = media, sd = deviazione_standard)\n```\n\n**Distribuzione Uniforme**:\n```r\nx <- seq(a, b, length.out = 100)\npdf_uniforme <- dunif(x, min = a, max = b)\n```\n\n**Distribuzione t di Student**:\n```r\nx <- seq(-5, 5, length.out = 100)\npdf_t <- dt(x, df = gradi_libertà)\n```\n\n---\n\n#### Calcolo dei Quantili\n\nI quantili si calcolano con le funzioni `qnorm`, `qunif` e `qt`. Ad esempio:\n\n**Distribuzione Normale**:\n```r\nprobabilità <- 0.5\nquantile_normale <- qnorm(probabilità, mean = media, sd = deviazione_standard)\n```\n\n**Distribuzione Uniforme**:\n```r\nquantile_uniforme <- qunif(probabilità, min = a, max = b)\n```\n\n**Distribuzione t di Student**:\n```r\nquantile_t <- qt(probabilità, df = gradi_libertà)\n```\n\n---\n\n#### Calcolo delle Probabilità Cumulate\n\nLe probabilità cumulate si calcolano con le funzioni `pnorm`, `punif` e `pt`. Ad esempio:\n\n**Distribuzione Normale**:\n```r\nquantile <- 0\nprobabilità_normale <- pnorm(quantile, mean = media, sd = deviazione_standard)\n```\n\n**Distribuzione Uniforme**:\n```r\nprobabilità_uniforme <- punif(quantile, min = a, max = b)\n```\n\n**Distribuzione t di Student**:\n```r\nprobabilità_t <- pt(quantile, df = gradi_libertà)\n```\n\n---\n\nCon questi strumenti, R consente di generare, visualizzare e analizzare campioni da una vasta gamma di distribuzioni di probabilità, fornendo un potente supporto all'inferenza bayesiana e alla modellazione statistica.\n\n## Esercizi\n\n::: {#exr-cont_rv_distr-1}\n\nPer ciascuna delle distribuzioni di massa di probabilità discusse, utilizza R per:\n\n- creare un grafico della funzione, scegliendo opportunamente i parametri;\n- estrarre un campione di 1000 valori casuali dalla distribuzione e visualizzarlo con un istogramma;\n- calcolare la media e la deviazione standard dei campioni e confrontarle con i valori teorici attesi;\n- stimare l'intervallo centrale del 94% utilizzando i campioni simulati;\n- determinare i quantili della distribuzione per gli ordini 0.05, 0.25, 0.75 e 0.95;\n- scegliendo un valore della distribuzione pari alla media più una deviazione standard, calcolare la probabilità che la variabile aleatoria assuma un valore minore o uguale a questo valore.\n\n:::\n\n## Informazioni sull'Ambiente di Sviluppo {.unnumbered}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] mice_3.17.0       viridis_0.6.5     viridisLite_0.4.2 gridExtra_2.3    \n#>  [5] patchwork_1.3.0   bayesplot_1.11.1  psych_2.4.6.26    scales_1.3.0     \n#>  [9] markdown_1.13     knitr_1.49        lubridate_1.9.4   forcats_1.0.0    \n#> [13] stringr_1.5.1     dplyr_1.1.4       purrr_1.0.2       readr_2.1.5      \n#> [17] tidyr_1.3.1       tibble_3.2.1      ggplot2_3.5.1     tidyverse_2.0.0  \n#> [21] rio_1.2.3         here_1.0.1       \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] gtable_0.3.6      shape_1.4.6.1     xfun_0.49         htmlwidgets_1.6.4\n#>  [5] lattice_0.22-6    tzdb_0.4.0        vctrs_0.6.5       tools_4.4.2      \n#>  [9] generics_0.1.3    parallel_4.4.2    fansi_1.0.6       pan_1.9          \n#> [13] pacman_0.5.1      jomo_2.7-6        pkgconfig_2.0.3   Matrix_1.7-1     \n#> [17] lifecycle_1.0.4   compiler_4.4.2    farver_2.1.2      munsell_0.5.1    \n#> [21] mnormt_2.1.1      codetools_0.2-20  htmltools_0.5.8.1 yaml_2.3.10      \n#> [25] glmnet_4.1-8      nloptr_2.1.1      pillar_1.9.0      MASS_7.3-61      \n#> [29] iterators_1.0.14  rpart_4.1.23      boot_1.3-31       mitml_0.4-5      \n#> [33] foreach_1.5.2     nlme_3.1-166      tidyselect_1.2.1  digest_0.6.37    \n#> [37] stringi_1.8.4     labeling_0.4.3    splines_4.4.2     rprojroot_2.0.4  \n#> [41] fastmap_1.2.0     grid_4.4.2        colorspace_2.1-1  cli_3.6.3        \n#> [45] magrittr_2.0.3    survival_3.7-0    utf8_1.2.4        broom_1.0.7      \n#> [49] withr_3.0.2       backports_1.5.0   timechange_0.3.0  rmarkdown_2.29   \n#> [53] nnet_7.3-19       lme4_1.1-35.5     hms_1.1.3         evaluate_1.0.1   \n#> [57] rlang_1.1.4       Rcpp_1.0.13-1     glue_1.8.0        minqa_1.2.8      \n#> [61] jsonlite_1.8.9    R6_2.5.1\n```\n:::\n\n\n\n\n\n## Bibliografia {.unnumbered}\n\n",
    "supporting": [
      "12_cont_rv_distr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}