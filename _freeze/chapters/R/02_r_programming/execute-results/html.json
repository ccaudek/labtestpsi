{
  "hash": "8bf433ba6b30dcfdc92e7a7849aebfd4",
  "result": {
    "engine": "knitr",
    "markdown": "# Programmazione in R {#sec-r-programming}\n\n::: callout-note\n## In questo capitolo imparerai a\n\n- Conoscere e sapere utilizzare le funzioni, le istruzioni condizionali e i cicli.\n:::\n\n::: callout-tip\n## Prerequisiti\n\n- Leggere [An Introduction to R](https://intro2r.com/).\n- Leggere [R for Data Science (2e)](https://r4ds.hadley.nz/).\n:::\n\n::: callout-important\n## Preparazione del Notebook\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyr)\n```\n:::\n\n\n\n:::\n\n## Introduzione\n\nIn questo capitolo esploreremo tre strumenti fondamentali per la scrittura di codice in R: le funzioni, le istruzioni condizionali e i cicli. Questi elementi costituiscono la base per sviluppare script flessibili, efficienti e riutilizzabili, essenziali per ogni programmatore o analista che utilizza R.\n\n## Funzioni\n\nR offre un'ampia gamma di funzioni integrate per supportare l'analisi statistica, la manipolazione dei dati e la visualizzazione grafica, rendendolo uno strumento estremamente versatile per diverse esigenze.\n\nEsempi di funzioni comuni includono:  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sommare numeri\nsum(1, 2, 3)  # Restituisce la somma dei numeri\n#> [1] 6\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creare un grafico semplice\nplot(1:10, 1:10)  # Crea un grafico a dispersione dei valori\n```\n\n::: {.cell-output-display}\n![](02_r_programming_files/figure-html/unnamed-chunk-3-1.png){width=576}\n:::\n:::\n\n\n\n\nIn sostanza, una funzione è un blocco di codice progettato per svolgere un’operazione specifica. Puoi pensare a una funzione come a una \"macchina\": fornisci un input (i dati), la funzione elabora l'informazione attraverso le sue istruzioni e restituisce un output (il risultato). Questo approccio modulare semplifica il lavoro, permettendo di riutilizzare e combinare facilmente diverse operazioni. \n\n### Creare Funzioni Personalizzate\n\nLa creazione di funzioni personalizzate in R è uno strumento essenziale per migliorare la programmazione, soprattutto per gestire operazioni ripetitive o complesse. Le funzioni consentono di rendere il codice più leggibile, efficiente e riutilizzabile, promuovendo un approccio organizzato e chiaro alla risoluzione dei problemi.\n\n#### Vantaggi delle Funzioni Personalizzate\n\nL'uso di funzioni personalizzate offre numerosi benefici:\n\n- **Chiarezza e leggibilità**: Un nome descrittivo permette di comprendere immediatamente lo scopo della funzione, anche a distanza di tempo o per altri utenti che leggono il codice.  \n- **Manutenzione semplificata**: Modificare il codice all'interno di una funzione aggiorna automaticamente tutte le sue occorrenze, riducendo il rischio di errori e semplificando il debugging.  \n- **Riduzione degli errori**: Si evitano gli errori tipici del copia-e-incolla, come omissioni o incoerenze nei programmi complessi.  \n- **Riutilizzabilità**: Una funzione ben progettata può essere utilizzata in più contesti o progetti, risparmiando tempo e sforzi.  \n\n#### Quando Creare una Funzione?\n\nUn buon criterio per decidere se creare una funzione è osservare se il medesimo blocco di codice viene copiato più volte. Se ti trovi a ripetere lo stesso codice più di due volte, probabilmente è il momento di creare una funzione. Questo aiuta a scrivere codice più pulito, scalabile e professionale, migliorando anche la sostenibilità del lavoro a lungo termine.\n\n---\n\n### Sintassi di una Funzione\n\nLa struttura base di una funzione in R è la seguente:\n\n```r\nnome_funzione <- function(argomenti) {\n  # Corpo della funzione\n  codice\n  return(risultato)  # Facoltativo: restituisce il valore calcolato\n}\n```\n\n- **`nome_funzione`**: Nome della funzione, scelto per descrivere chiaramente la sua finalità.  \n- **`argomenti`**: Parametri necessari per eseguire le operazioni all'interno della funzione.  \n- **`codice`**: Le istruzioni che definiscono il comportamento della funzione.  \n- **`risultato`**: Il valore restituito dalla funzione. Se non si usa `return()`, R restituisce l'ultimo valore calcolato.  \n\n---\n\n### Esempio Pratico\n\nImmaginiamo di voler creare una funzione per sommare due numeri. \n\n```r\nsomma_due <- function(a, b) {\n  a + b  # Restituisce la somma dei due numeri\n}\n```\n\nPer utilizzarla, basta richiamarla specificando i parametri:\n\n```r\nsomma_due(5, 3)  # Restituisce 8\n```\n\nQuesto approccio aiuta a scrivere codice più leggibile e facile da gestire. Ad esempio, se in futuro volessi modificare il comportamento della somma (ad esempio, aggiungere un messaggio di log), basterà intervenire solo all’interno della funzione.\n\n### Tre Tipi di Funzioni\n\nSeguendo @wickham2023r, esaminiamo tre tipi di funzioni:\n\n- **Funzioni per vettori**: accettano uno o più vettori come input e restituiscono un vettore.\n- **Funzioni per data frame**: accettano un data frame e restituiscono un altro data frame.\n- **Funzioni per grafici**: accettano un data frame e restituiscono un grafico.\n\n#### Funzioni per Vettori\n\nSupponiamo di voler riscalare i valori di diverse colonne di un data frame tra 0 e 1. Scriviamo la funzione `rescale01`. La funzione seguente riscalerà un vettore tra 0 e 1:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrescale01 <- function(x) {\n    rng <- range(x, na.rm = TRUE)\n    (x - rng[1]) / (rng[2] - rng[1])\n}\n```\n:::\n\n\n\n\n::: {#exm-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n    x = c(3, 2, 6, 3, 1),\n    y = c(2, 3, 3, 2, 5),\n    grp = c(\"a\", \"a\", \"b\", \"b\", \"a\")\n)\n\ndf |>\n    mutate(across(where(is.numeric), rescale01))\n#> # A tibble: 5 × 3\n#>       x     y grp  \n#>   <dbl> <dbl> <chr>\n#> 1   0.4 0     a    \n#> 2   0.2 0.333 a    \n#> 3   1   0.333 b    \n#> 4   0.4 0     b    \n#> 5   0   1     a\n```\n:::\n\n\n\n:::\n\n#### Funzioni per Data Frame\n\nPoniamoci il problema di creare una funzione per riassumere variabili. Un esempio di funzione che calcola statistiche di base:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_stats <- function(data, var) {\n    data |> summarize(\n        min = min({{ var }}, na.rm = TRUE),\n        mean = mean({{ var }}, na.rm = TRUE),\n        max = max({{ var }}, na.rm = TRUE),\n        .groups = \"drop\"\n    )\n}\n```\n:::\n\n\n\n\n::: {#exm-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_stats(df, x)\n#> # A tibble: 1 × 3\n#>     min  mean   max\n#>   <dbl> <dbl> <dbl>\n#> 1     1     3     6\n```\n:::\n\n\n\n\nSi noti la selezione dinamica con `{}` (embracing). Se devi passare nomi di variabili come argomenti, usa `{{ }}`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped_mean <- function(df, group_var, mean_var) {\n    df |>\n        group_by({{ group_var }}) |>\n        summarize(mean = mean({{ mean_var }}, na.rm = TRUE))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped_mean(df, grp, y)\n#> # A tibble: 2 × 2\n#>   grp    mean\n#>   <chr> <dbl>\n#> 1 a      3.33\n#> 2 b      2.5\n```\n:::\n\n\n\n:::\n\n#### Funzioni per Grafici\n\nCreare un istogramma personalizzato.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_histogram <- function(df, var, binwidth = NULL) {\n    df |>\n        ggplot(aes(x = {{ var }})) +\n        geom_histogram(binwidth = binwidth)\n}\n```\n:::\n\n\n\n\n::: {#exm-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |>\n    my_histogram(carat, 0.1)\n```\n\n::: {.cell-output-display}\n![](02_r_programming_files/figure-html/unnamed-chunk-11-1.png){width=576}\n:::\n:::\n\n\n\n:::\n\n### Stile e Nomenclatura\n\nÈ consigliato di usare nomi di funzioni chiari e descrittivi, preferibilmente verbi (es. `compute_mean()`). Inoltre, è importante mantenere una struttura leggibile, con spazi coerenti e indentazione.\n\n## Istruzioni Condizionali in R\n\nLe istruzioni condizionali permettono di introdurre logica nel tuo codice. Ad esempio, l’operazione `x * y` si limita a moltiplicare i valori di `x` e `y`, senza alcuna logica aggiunta. Con le istruzioni condizionali, puoi dire al programma di eseguire diverse operazioni a seconda che una condizione sia vera (`TRUE`) o falsa (`FALSE`).\n\nL’istruzione condizionale più comune in R è `if`. Può essere letta come: **\"Se la condizione è vera, esegui un’azione\"**. Con `else`, si estende la logica: **\"Se la condizione è vera, fai qualcosa; altrimenti fai qualcos’altro\"**.\n\nLa struttura generale è questa:\n\n```R\nif (condizione) {\n  # Codice eseguito se la condizione è TRUE\n} else {\n  # Codice eseguito se la condizione è FALSE\n}\n```\n\nImmagina questa situazione:\n\n- Un programmatore riceve la richiesta: \"Vai al negozio e compra una confezione di latte, e se hanno le uova, prendi sei confezioni di latte\".\n- Il programmatore torna con **sei confezioni di latte**.\n- Il partner chiede: \"Perché hai comprato sei confezioni di latte?\"\n- Risposta: \"Perché c’erano le uova\".\n\nIl problema qui sta nell’interpretazione condizionale: se ci sono uova (condizione vera), si doveva prendere una confezione di latte **e anche** sei uova.\n\nIn R, questo può essere scritto così:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neggs <- TRUE # Indica se il negozio ha le uova\n\nif (eggs == TRUE) {\n    n_milk <- 6 # Prendi 6 confezioni di latte\n} else {\n    n_milk <- 1 # Prendi 1 confezione di latte\n}\n\nn_milk\n#> [1] 6\n```\n:::\n\n\n\n\nQuesto codice però ha lo stesso errore della barzelletta: il focus è sul latte, non sulle uova.\n\n### Uso di `ifelse()`\n\nUn’alternativa più compatta a `if` e `else` è la funzione `ifelse()`, utile soprattutto per vettori. Ad esempio:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\neggs <- TRUE\nn_milk <- ifelse(eggs == TRUE, yes = 6, no = 1)\n\nn_milk\n#> [1] 6\n```\n:::\n\n\n\n\nLa logica è: **\"Se ci sono uova, assegna 6 a `n_milk`; altrimenti assegna 1\"**. Questo approccio è utile per evitare codice ripetitivo.\n\n### Creare una funzione con istruzioni condizionali\n\nLe istruzioni condizionali possono essere racchiuse in una funzione per rendere il codice più flessibile e riutilizzabile. Ecco come trasformare l’esempio sopra in una funzione:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmilk <- function(eggs) {\n    if (eggs == TRUE) {\n        6\n    } else {\n        1\n    }\n}\n\nmilk(eggs = TRUE)\n#> [1] 6\n```\n:::\n\n\n\n\nOra possiamo chiamare la funzione con `eggs = TRUE` o `eggs = FALSE` per determinare quante confezioni di latte prendere.\n\nIn conclusione, le istruzioni condizionali come `if`, `else` e `ifelse()` sono strumenti fondamentali per introdurre logica e controllo nel tuo codice. Puoi usarle per prendere decisioni, gestire errori e rendere il tuo codice più flessibile ed efficiente. Creare funzioni che incorporano queste istruzioni è un passo fondamentale per scrivere codice ordinato e riutilizzabile.\n\n### Combinare operatori logici in R\n\nFinora abbiamo creato funzioni abbastanza semplici e mirate. Ora proviamo a realizzare una funzione leggermente più complessa. Immaginiamo di voler determinare se una persona ha avuto **una buona giornata** basandoci su due criteri:\n\n1. **Livello di stress**: basso (`TRUE`) o alto (`FALSE`).\n2. **Livello di supporto sociale percepito**: alto (`TRUE`) o basso (`FALSE`).\n\nVogliamo creare una funzione che prenda questi due fattori e restituisca un messaggio che descrive come potrebbe essere stata la giornata della persona.\n\nEcco come possiamo costruire la funzione:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngood_day <- function(low_stress, high_support) {\n    if (low_stress == TRUE && high_support == TRUE) {\n        \"Giornata fantastica! Ti senti calmo e supportato.\"\n    } else if (low_stress == FALSE && high_support == TRUE) {\n        \"Il supporto sociale ti aiuta a gestire lo stress elevato.\"\n    } else if (low_stress == TRUE && high_support == FALSE) {\n        \"Nonostante lo stress sia basso, la mancanza di supporto sociale pesa.\"\n    } else if (low_stress == FALSE && high_support == FALSE) {\n        \"Giornata difficile: stress elevato e poco supporto sociale.\"\n    }\n}\n```\n:::\n\n\n\n\nEsempi di utilizzo.\n\nCaso 1: Stress basso e supporto sociale alto\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngood_day(low_stress = TRUE, high_support = TRUE)\n#> [1] \"Giornata fantastica! Ti senti calmo e supportato.\"\n```\n:::\n\n\n\n\nCaso 2: Stress elevato e supporto sociale alto.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngood_day(FALSE, TRUE)\n#> [1] \"Il supporto sociale ti aiuta a gestire lo stress elevato.\"\n```\n:::\n\n\n\n\nCaso 3: Stress basso e supporto sociale basso.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngood_day(TRUE, FALSE)\n#> [1] \"Nonostante lo stress sia basso, la mancanza di supporto sociale pesa.\"\n```\n:::\n\n\n\n\nCaso 4: Stress elevato e supporto sociale basso.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngood_day(FALSE, FALSE)\n#> [1] \"Giornata difficile: stress elevato e poco supporto sociale.\"\n```\n:::\n\n\n\n\nLa funzione considera tutte le combinazioni di stress e supporto sociale:\n\n1. **Stress basso e supporto alto**: giornata ideale.\n2. **Stress elevato e supporto alto**: il supporto aiuta a mitigare lo stress.\n3. **Stress basso e supporto basso**: la mancanza di supporto rovina una situazione potenzialmente buona.\n4. **Stress elevato e supporto basso**: la situazione peggiore.\n\n\nNell'esempio abbiamo usato i seguenti operatori logici:\n\n- **`&&` (AND logico)**: Entrambe le condizioni devono essere vere.\n- **`==` (uguale a)**: Verifica se una variabile è vera o falsa.\n\nAd esempio, questa condizione:\n\n```R\nif (low_stress == TRUE && high_support == TRUE)\n```\nverifica se il livello di stress è basso **e** il supporto sociale è alto.\n\nIn conclusione, questa funzione dimostra come combinare condizioni logiche complesse utilizzando operatori logici come `&&` (AND) e `||` (OR). Grazie a questi strumenti, possiamo gestire facilmente logiche più articolate, mantenendo il codice leggibile e funzionale.\n\n### Gli operatori logici in R\n\nGli operatori logici sono essenziali per definire le condizioni nelle istruzioni `if`. Ecco una tabella riassuntiva con i principali operatori:\n\n| **Operatore** | **Descrizione tecnica**         | **Significato**                     | **Esempio**                        |\n|---------------|---------------------------------|-------------------------------------|-------------------------------------|\n| `&&`          | AND logico                     | Entrambe le condizioni devono essere vere | `if(cond1 == test && cond2 == test)` |\n| `||`          | OR logico                      | Almeno una condizione deve essere vera | `if(cond1 == test || cond2 == test)` |\n| `<`           | Minore di                     | X è minore di Y                    | `if(X < Y)`                        |\n| `>`           | Maggiore di                   | X è maggiore di Y                  | `if(X > Y)`                        |\n| `<=`          | Minore o uguale a             | X è minore o uguale a Y            | `if(X <= Y)`                       |\n| `>=`          | Maggiore o uguale a           | X è maggiore o uguale a Y          | `if(X >= Y)`                       |\n| `==`          | Uguale a                      | X è uguale a Y                     | `if(X == Y)`                       |\n| `!=`          | Diverso da                    | X è diverso da Y                   | `if(X != Y)`                       |\n\n## Cicli in R\n\nR è particolarmente efficace nell'eseguire attività ripetitive. Quando dobbiamo ripetere un'operazione più volte, possiamo utilizzare un **ciclo**. I cicli eseguono un insieme di istruzioni per un numero specifico di volte o fino a quando una determinata condizione non è soddisfatta. \n\nIn R esistono tre tipi principali di cicli:\n\n1. **Ciclo `for`**: ripete un'operazione per un numero definito di iterazioni.\n2. **Ciclo `while`**: continua a eseguire le istruzioni fino a quando una condizione logica è soddisfatta.\n3. **Ciclo `repeat`**: itera indefinitamente fino a quando non viene esplicitamente interrotto con un'istruzione `break`.\n\nI cicli sono strumenti essenziali in tutti i linguaggi di programmazione, ma in R il loro utilizzo dovrebbe essere valutato attentamente, poiché spesso esistono alternative più efficienti come le funzioni della famiglia `apply`.\n\n### Il ciclo `for`\n\nIl ciclo `for` è il più utilizzato per eseguire un’operazione un numero definito di volte. Ecco un esempio base:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n    print(i)\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n\n\n**Come funziona?**\n\n- L'indice `i` prende il primo valore della sequenza `1:5` (cioè 1).\n- Il corpo del ciclo, ovvero il codice tra `{ }`, viene eseguito.\n- Al termine di ogni iterazione, `i` assume il valore successivo nella sequenza, e il processo si ripete fino all'ultimo valore (5 in questo caso).\n\n**Aggiungere logica nel corpo del ciclo**\n\nPossiamo aggiungere operazioni all'interno del ciclo, come ad esempio sommare 1 a ogni valore:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n    print(i + 1)\n}\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n#> [1] 6\n```\n:::\n\n\n\n\n### Il ciclo `while`\n\nIl ciclo `while` continua a eseguire le istruzioni fino a quando una condizione logica è soddisfatta. Ecco un esempio:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 0\nwhile (i <= 4) {\n    i <- i + 1\n    print(i)\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n\n\n**Come funziona?**\n\n- La condizione logica (`i <= 4`) viene verificata prima di ogni iterazione.\n- Se la condizione è vera, il ciclo esegue il codice tra `{ }`.\n- Quando la condizione diventa falsa (`i > 4`), il ciclo si interrompe.\n\n### Ciclo `repeat`\n\nIl ciclo `repeat` esegue il codice indefinitamente, a meno che non venga interrotto con un’istruzione `break`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 0\nrepeat {\n    i <- i + 1\n    print(i)\n    if (i >= 5) {\n        break\n    }\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n:::\n\n\n\n\n**Quando usarlo?**\n\nIl ciclo `repeat` è raro e viene utilizzato solo in situazioni molto particolari. Nella maggior parte dei casi, `for` o `while` sono più adatti.\n\n### Evitare i cicli: la famiglia di funzioni `apply`\n\nI cicli in R sono relativamente lenti, specialmente con dataset di grandi dimensioni. Quando possibile, è preferibile usare funzioni della famiglia `apply` per ottenere lo stesso risultato in modo più efficiente e con meno rischi di errore.\n\n#### La funzione `lapply()`\n\n`lapply()` esegue una funzione su ciascun elemento di una lista o vettore e restituisce una lista con i risultati.\n\nEsempio:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(0:4, function(a) {\n    a + 1\n})\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3\n#> \n#> [[4]]\n#> [1] 4\n#> \n#> [[5]]\n#> [1] 5\n```\n:::\n\n\n\n\n#### La funzione `sapply()`\n\n`lapply()` restituisce una lista, ma se vuoi un vettore come output, usa `sapply()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(0:4, function(a) {\n    a + 1\n})\n#> [1] 1 2 3 4 5\n```\n:::\n\n\n\n\n### Quando usare i cicli?\n\nI cicli sono utili quando:\n\n- Devi simulare modelli complessi (es. modelli ricorsivi).\n- Hai bisogno di operazioni che dipendono dai risultati delle iterazioni precedenti.\n\nIn tutti gli altri casi, considera alternative come `apply()`, `lapply()` o funzioni simili per un codice più efficiente e meno soggetto a errori.\n\n## Linee Guida per Scrivere Codice\n\nDi seguito trovi alcune linee guida per scrivere codice chiaro, conciso e riutilizzabile:\n\n1. **Evita di ripeterti**: Segui il principio *Don't Repeat Yourself* (DRY). Scrivi funzioni e utilizza funzioni come `map` (per applicare un pezzo di codice iterativamente a tutti gli elementi di un oggetto) per evitare di copiare e incollare variazioni minime dello stesso codice in più parti del progetto.\n\n2. **Segui uno stile coerente**: Adotta una guida di stile per mantenere uniformità nel tuo codice. Per R, raccomandiamo la [guida di stile](https://style.tidyverse.org/) del “tidyverse”, scritta da Hadley Wickham. Questa guida, derivata dalla Google R Style Guide, fornisce istruzioni dettagliate su sintassi del codice, nomi delle variabili, spaziature, indentazioni, commenti, convenzioni per scrivere funzioni, utilizzo delle pipe (metodo per concatenare funzioni), e altro ancora. \n\n3. **Commenta abbondantemente**: Usa i commenti (ad esempio, con `#`) per spiegare perché ogni parte del codice è necessaria e cosa fa. I commenti rendono il codice più leggibile e facilitano la manutenzione futura.\n\n4. **Testa il tuo codice**: Ogni volta che scrivi codice, verifica che funzioni come previsto. Puoi farlo scrivendo funzioni di test specifiche o controllando manualmente che l’output corrisponda alle aspettative. Abituati a pensare a eventuali *edge cases* (casi limite) in cui il tuo codice potrebbe non comportarsi come previsto.\n\n5. **Esegui una revisione del codice**: Quando possibile, fai revisionare il tuo codice da un’altra persona per individuare errori e incoerenze. Se non hai nessuno a disposizione, puoi rivedere il tuo codice autonomamente: rileggendo con attenzione, è sorprendente il numero di errori che si possono individuare!\n\nSeguendo queste linee guida, potrai scrivere codice più robusto, leggibile e facile da mantenere nel tempo.[^1]\n\n[^1]: Un’ottima introduzione alle regole di stile per un progetto di analisi dei dati è fornita in questo [capitolo](https://datamgmtinedresearch.com/style).\n\n## Riflessioni Conclusive\n\nScrivere funzioni è un passaggio essenziale per migliorare la leggibilità, l’efficienza e la riutilizzabilità del codice. Funzioni ben progettate semplificano le modifiche, riducono errori e rendono il lavoro più chiaro, sia per te stesso che per i collaboratori futuri. Se trovi che stai copiando e incollando codice più volte, è il momento di pensare a creare una funzione.\n\nLe istruzioni condizionali, come `if`, `else` e `ifelse()`, sono fondamentali per introdurre logica e controllo nel codice. Permettono di gestire scenari diversi e prendere decisioni dinamiche, migliorando la flessibilità e l’efficienza dei tuoi script. Combinando queste istruzioni con operatori logici come `&&` e `||`, puoi affrontare situazioni complesse con un codice chiaro e leggibile.\n\nI cicli sono potenti strumenti per eseguire operazioni ripetitive, ma in R il loro utilizzo dovrebbe essere limitato ai casi in cui non esistono alternative più efficienti. Le funzioni `apply()` e simili rappresentano spesso un’opzione migliore per manipolare dati in modo più rapido e leggibile.\n\n## Informazioni sull'Ambiente di Sviluppo {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] viridis_0.6.5     viridisLite_0.4.2 gridExtra_2.3     patchwork_1.3.0  \n#>  [5] bayesplot_1.11.1  psych_2.4.6.26    scales_1.3.0      markdown_1.13    \n#>  [9] knitr_1.49        lubridate_1.9.4   forcats_1.0.0     stringr_1.5.1    \n#> [13] dplyr_1.1.4       purrr_1.0.2       readr_2.1.5       tidyr_1.3.1      \n#> [17] tibble_3.2.1      ggplot2_3.5.1     tidyverse_2.0.0   rio_1.2.3        \n#> [21] here_1.0.1       \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] utf8_1.2.4        generics_0.1.3    stringi_1.8.4     lattice_0.22-6   \n#>  [5] hms_1.1.3         digest_0.6.37     magrittr_2.0.3    evaluate_1.0.1   \n#>  [9] grid_4.4.2        timechange_0.3.0  fastmap_1.2.0     rprojroot_2.0.4  \n#> [13] jsonlite_1.8.9    fansi_1.0.6       mnormt_2.1.1      cli_3.6.3        \n#> [17] rlang_1.1.4       munsell_0.5.1     withr_3.0.2       tools_4.4.2      \n#> [21] parallel_4.4.2    tzdb_0.4.0        colorspace_2.1-1  pacman_0.5.1     \n#> [25] vctrs_0.6.5       R6_2.5.1          lifecycle_1.0.4   htmlwidgets_1.6.4\n#> [29] pkgconfig_2.0.3   pillar_1.9.0      gtable_0.3.6      glue_1.8.0       \n#> [33] xfun_0.49         tidyselect_1.2.1  farver_2.1.2      htmltools_0.5.8.1\n#> [37] nlme_3.1-166      labeling_0.4.3    rmarkdown_2.29    compiler_4.4.2\n```\n:::\n\n\n\n\n## Bibliografia {.unnumbered}\n",
    "supporting": [
      "02_r_programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}