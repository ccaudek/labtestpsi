{
  "hash": "abd188a0ea2cdd52beedeabbb4d26e72",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  freeze: auto\n---\n\n\n\n\n# Introduzione a R e RStudio {#sec-r}\n\n::: callout-note  \n## In questo capitolo imparerai a:  \n\n- installare R e RStudio;\n- creare e gestire progetti in RStudio;\n- manipolare oggetti e vettori in R;\n- utilizzare funzioni e lavorare con dati mancanti;\n- estrarre e gestire sottoinsiemi di dati.\n:::  \n\n::: callout-tip\n## Prerequisiti\n\n- Leggere [An Introduction to R](https://intro2r.com/).\n- Leggere [R for Data Science (2e)](https://r4ds.hadley.nz/).\n:::\n\n::: callout-important\n## Preparazione del Notebook\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyr)\n```\n:::\n\n\n\n:::\n\n## Introduzione\n\nNegli ultimi anni, la **crisi della replicabilità** ha messo in luce problemi significativi nella scienza: molte analisi non possono essere riprodotte, minando la fiducia nei risultati pubblicati [@nosek2022replicability]. Per affrontare questa sfida, è fondamentale adottare strumenti che promuovano **trasparenza**, **riproducibilità** e **rigore metodologico**. R si distingue come uno strumento ideale per soddisfare queste esigenze, grazie a tre punti di forza principali:\n\n1. **Scripting e documentazione trasparente.** \n  Ogni analisi in R viene realizzata attraverso script che documentano in modo esplicito tutti i passaggi. Questo approccio offre numerosi vantaggi:\n\n    - Gli script possono essere **salvati**, **condivisi** e **rivisti**, garantendo che ogni aspetto del processo analitico sia accessibile e riproducibile.\n    - La possibilità di eseguire gli stessi script con nuovi dati consente di verificare i risultati originali o applicare l’analisi in contesti differenti.\n\n2. **Flessibilità e personalizzazione.** \n  R fornisce un ambiente altamente flessibile, che permette di:\n\n    - **Adattare i flussi di lavoro** a problemi specifici o a nuovi set di dati.\n    - Sfruttare una vasta libreria di pacchetti che coprono metodi statistici avanzati, visualizzazione dei dati e machine learning.\n    - Sviluppare funzioni personalizzate per rispondere a esigenze analitiche uniche.\n\n3. **Integrazione con strumenti di reporting.** \n  R si integra perfettamente con strumenti come **R Markdown** e **Quarto**, che consentono di combinare analisi, codice e risultati in un unico documento dinamico. Questo approccio offre:\n\n    - La possibilità di creare report automatici, aggiornabili semplicemente modificando i dati sottostanti.\n    - Un formato unificato che include testo descrittivo, codice e output (grafici, tabelle, statistiche), facilitando la comunicazione scientifica.\n\nA differenza di software con interfacce grafiche (GUI), che spesso introducono **errori nascosti** e rendono difficile documentare il flusso di lavoro, R favorisce un approccio basato su **codice esplicito**. Questo approccio:\n\n- Elimina ambiguità, poiché ogni operazione è descritta chiaramente nello script.\n- Incrementa la verificabilità, consentendo a terzi di esaminare ogni passaggio dell’analisi.\n\nUtilizzare R non significa solo apprendere uno strumento tecnico, ma adottare un approccio scientifico moderno e replicabile. Lavorare in R risponde alle richieste di una ricerca affidabile e contribuisce a contrastare la crisi della replicabilità, favorendo analisi **trasparenti**, **rigorose** e **comunicabili**.\n\n## Installare R e RStudio\n\n1. **Scarica e installa R**  \n   Vai al sito ufficiale di CRAN (https://cran.r-project.org/), scegli la versione per il tuo sistema operativo (Windows, Mac o Linux) e segui le istruzioni di installazione.\n\n2. **Scarica e installa RStudio**  \n   Dopo aver installato R, scarica RStudio dal sito ufficiale (https://posit.co/download/rstudio-desktop/). Scegli la versione gratuita \"RStudio Desktop\" e segui le istruzioni per il tuo sistema operativo.\n\nUna spiegazione dettagliata del processo di installazione di R e RStudio è disponibile in @okoye2024introduction.\n\n## Panoramica sull'interfaccia di RStudio\n\nRStudio rende l’uso di R più intuitivo grazie alla sua interfaccia divisa in quattro pannelli principali:\n\n- **Pannello degli script**: Qui puoi scrivere e modificare i tuoi script, cioè sequenze di comandi salvabili per analisi ripetibili e organizzate.\n- **Console**: Esegue i comandi scritti direttamente o lanciati dagli script, mostrando risultati, messaggi e errori.\n- **Pannello dell’ambiente**: Mostra i dataset, le variabili e gli oggetti caricati nella sessione di lavoro, permettendoti di gestire facilmente i dati.\n- **Pannello grafici/aiuto/file**: Visualizza grafici, fornisce accesso alla documentazione di R e consente di navigare tra file e cartelle sul tuo sistema.\n\n## Creare un Nuovo Progetto in RStudio\n\n**Avviare un nuovo progetto**  \nDal menu di RStudio, seleziona **File > New Project...** per creare un nuovo progetto. I progetti in RStudio sono uno strumento efficace per organizzare il lavoro relativo a una specifica analisi o domanda di ricerca. All'interno di un progetto puoi raccogliere script, file di dati e output, mantenendo tutto ben strutturato.\n\n**Scegliere la posizione del progetto**  \nPuoi creare una nuova directory dedicata al progetto oppure associare il progetto a una directory esistente. Organizzare i progetti in cartelle dedicate aiuta a mantenere i file in ordine e a utilizzare percorsi relativi, rendendo il tuo lavoro più facile da condividere con collaboratori e più portabile tra diversi sistemi. \n\nQuesta organizzazione è particolarmente utile per evitare confusione e assicurarsi che tutti i file necessari siano facilmente accessibili e collegati al progetto corretto.\n\n## Concetti di Base nella Programmazione in R\n\nIniziare a usare R, soprattutto per chi si avvicina per la prima volta a questo linguaggio nel contesto della psicologia, significa comprendere i concetti fondamentali che ne costituiscono la base. Questo capitolo introduce i principi essenziali della programmazione in R, tra cui:\n\n- La comprensione della **sintassi di R**.\n- La familiarizzazione con i principali **tipi di dati** e **strutture**. \n- L’acquisizione delle **operazioni di base**.\n\nQuesti concetti sono fondamentali per manipolare efficacemente i dati e condurre analisi statistiche, rappresentando il punto di partenza per sfruttare al meglio le potenzialità di R.\n\n## Oggetti in R\n\nIn R, tutto è un oggetto: dai numeri o stringhe di testo semplici, fino a strutture più complesse come grafici, riassunti di analisi statistiche o script che eseguono compiti specifici. Creare e assegnare valori agli oggetti è fondamentale per lavorare in R.\n\n### Creare oggetti\n\nPer creare un oggetto, basta assegnargli un nome e un valore usando l’operatore di assegnazione `<-`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_obj <- 48\n```\n:::\n\n\n\n\nIn questo esempio, abbiamo creato un oggetto chiamato `my_obj` e gli abbiamo assegnato il valore 48. Anche l'operatore `=` può essere usato, ma è considerato una cattiva pratica.\n\nPer visualizzare il valore di un oggetto, basta scriverne il nome:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_obj\n#> [1] 48\n```\n:::\n\n\n\n\nGli oggetti creati vengono memorizzati nell'ambiente di lavoro. In RStudio, puoi visualizzarli nella scheda **Environment** e ottenere dettagli come tipo, lunghezza e valore.\n\nÈ possibile assegnare a un oggetto anche una stringa di testo, racchiudendola tra virgolette:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_obj2 <- \"R è fantastico\"\nmy_obj2\n#> [1] \"R è fantastico\"\n```\n:::\n\n\n\n\nSe dimentichi le virgolette, R mostrerà un errore.\n\nPer modificare il valore di un oggetto esistente, basta riassegnarlo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_obj2 <- 1024\n```\n:::\n\n\n\n\nOra il tipo di `my_obj2` è cambiato da carattere a numerico. È anche possibile usare oggetti per crearne di nuovi:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_obj3 <- my_obj + my_obj2\nmy_obj3\n#> [1] 1072\n```\n:::\n\n\n\n\nSe provi a sommare oggetti di tipo diverso, R restituirà un errore:\n\n```\nchar_obj <- \"ciao\"\nchar_obj2 <- \"mondo\"\nchar_obj3 <- char_obj + char_obj2\n#> Error in char_obj + char_obj2 : non-numeric argument to binary operator\n```\n\nQuando incontri errori come questo, chiedi a AI la spiegazione del messaggio, per esempio: \"non-numeric argument to binary operator error + r\". Un errore comune è anche:\n\n```\nmy_obj <- 48\nmy_obj4 <- my_obj + no_obj\n#> Error: object 'no_obj' not found\n```\n\nR segnala che `no_obj` non è stato definito e, di conseguenza, l’oggetto `my_obj4` non è stato creato.\n\n### Nomi degli oggetti\n\nDare un nome agli oggetti può sembrare banale, ma è importante scegliere nomi brevi e informativi. Usa un formato coerente, come:\n\n- **Snake case**: `output_summary`\n- **Dot case**: `output.summary`\n- **Camel case**: `outputSummary`\n\nEvita di iniziare i nomi con numeri (es. `2my_variable`) o caratteri speciali (&, ^, /, ecc.). Inoltre, non usare parole riservate (es. `TRUE`, `NA`) o nomi di funzioni già esistenti (es. `data`).\n\nEsempio da evitare:\n\n```\ndata <- read.table(\"mydatafile\", header = TRUE) # `data` è già una funzione!\n```\n\n## Commenti\n\nI commenti nel linguaggio di programmazione (in questo caso R) sono parti del codice che il linguaggio stesso ignora completamente, ovvero non vengono eseguite. La loro funzione principale è aiutare il programmatore a chiarire cosa fanno le diverse parti del codice, rendendolo più comprensibile sia a sé stessi sia ad altri. In R, come si può osservare nell'esempio sopra, i commenti iniziano con il simbolo `#`. Tutto ciò che segue il simbolo `#` sulla stessa riga viene ignorato durante l'esecuzione del codice. \n\nÈ una buona pratica commentare frequentemente il codice, soprattutto nei punti in cui le decisioni prese non risultano immediatamente evidenti. I commenti dovrebbero spiegare **perché** si sta facendo qualcosa, piuttosto che **come** viene fatto: il \"come\" è già descritto dal codice stesso. \n\nAd esempio, invece di scrivere un commento come:\n\n```r\n# Assegno 42 alla variabile x\nx <- 42\n```\n\nè più utile spiegare il contesto o la motivazione:\n\n```r\n# Valore iniziale scelto per semplificare i calcoli successivi\nx <- 42\n```\n\nQuesto approccio aiuta chiunque legga il codice (incluso il futuro te stesso!) a comprendere le intenzioni alla base delle scelte fatte, riducendo il tempo necessario per interpretarlo o modificarlo. Un codice ben commentato è quindi non solo più comprensibile, ma anche più facile da mantenere e riutilizzare.\n\n## Usare le funzioni in R \n\nFino ad ora abbiamo creato oggetti semplici assegnando loro direttamente un valore. Con l'aumento dell'esperienza in R, potresti voler creare oggetti più complessi. Per aiutarti, R offre numerose funzioni già disponibili nella sua installazione di base, e altre possono essere aggiunte installando pacchetti. Una funzione è un insieme di istruzioni che eseguono un compito specifico. Inoltre, è possibile creare funzioni personalizzate.\n\n### La funzione `c()` per creare vettori\n\nLa prima funzione utile da imparare è `c()`, che serve a concatenare valori in un *vettore*. Ad esempio:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)\n```\n:::\n\n\n\n\nQuesto codice crea un oggetto chiamato `my_vec` che contiene una sequenza di numeri. Alcuni concetti fondamentali sulle funzioni in R:\n\n1. **Nome e parentesi**: Le funzioni in R sono sempre seguite da parentesi tonde `()`.\n2. **Argomenti**: Gli elementi passati alla funzione (tra le parentesi) ne personalizzano il comportamento e sono separati da virgole.\n\nPer vedere il contenuto del vettore:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec\n#> [1] 2 3 1 6 4 3 3 7\n```\n:::\n\n\n\n\n### Funzioni per analizzare vettori\n\nPuoi utilizzare altre funzioni per calcolare statistiche sul vettore:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(my_vec)    # Media\n#> [1] 3.62\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(my_vec)     # Varianza\n#> [1] 3.98\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(my_vec)      # Deviazione standard\n#> [1] 2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(my_vec)  # Numero di elementi\n#> [1] 8\n```\n:::\n\n\n\n\nPuoi anche salvare i risultati in nuovi oggetti per riutilizzarli:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_mean <- mean(my_vec)\nvec_mean\n#> [1] 3.62\n```\n:::\n\n\n\n\n### Creare sequenze regolari\n\nPer creare sequenze di numeri in passi regolari, puoi usare i seguenti comandi.\n\n**Simbolo `:`** per sequenze semplici:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq <- 1:10\nmy_seq\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n\n\n\n**Funzione `seq()`** per maggiore controllo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq2 <- seq(from = 1, to = 5, by = 0.5)\nmy_seq2\n#> [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n```\n:::\n\n\n\n\n### Ripetere valori\n\nPuoi ripetere valori o sequenze con la funzione `rep()`.\n\nRipetere un valore:\n  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq3 <- rep(2, times = 10)\nmy_seq3\n#>  [1] 2 2 2 2 2 2 2 2 2 2\n```\n:::\n\n\n\n\nRipetere una sequenza:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq5 <- rep(1:5, times = 3)\n```\n:::\n\n\n\n\nRipetere ogni elemento di una sequenza:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq6 <- rep(1:5, each = 3)\nmy_seq6\n#>  [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5\n```\n:::\n\n\n\n\n### Annidare funzioni\n\nÈ possibile combinare funzioni per creare comandi più complessi, come nell'esempio:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq7 <- rep(c(3, 1, 10, 7), each = 3)\nmy_seq7\n#>  [1]  3  3  3  1  1  1 10 10 10  7  7  7\n```\n:::\n\n\n\n\nPer maggiore leggibilità, puoi separare i passaggi:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nin_vec <- c(3, 1, 10, 7)\nmy_seq7 <- rep(in_vec, each = 3)\nmy_seq7\n#>  [1]  3  3  3  1  1  1 10 10 10  7  7  7\n```\n:::\n\n\n\n\nQuesta pratica facilita la comprensione del codice e lo rende più chiaro.\n\n\n## Lavorare con i vettori in R \n\nIn R, i vettori sono uno degli elementi fondamentali per manipolare, riassumere e ordinare i dati. Qui trovi una panoramica su come estrarre, sostituire, ordinare, lavorare con dati mancanti e sfruttare la vettorizzazione dei vettori.\n\n### Estrarre elementi da un vettore\n\nPuoi estrarre uno o più elementi da un vettore usando le parentesi quadre `[ ]`.\n\n**Per posizione**: Specifica la posizione degli elementi.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)\nmy_vec[3]  # Terzo elemento\n#> [1] 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[c(1, 5, 6)]  # Elementi 1°, 5° e 6°\n#> [1] 2 4 3\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[3:8]  # Da 3° a 8°\n#> [1] 1 6 4 3 3 7\n```\n:::\n\n\n\n\n**Con condizioni logiche**: Usa espressioni logiche per selezionare elementi.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[my_vec > 4]  # Elementi > 4\n#> [1] 6 7\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[my_vec <= 4]  # Elementi ≤ 4\n#> [1] 2 3 1 4 3 3\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[my_vec != 4]  # Elementi diversi da 4\n#> [1] 2 3 1 6 3 3 7\n```\n:::\n\n\n\n\n**Operatori logici**: Combina condizioni con `&` (AND) e `|` (OR).  \n   \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[my_vec > 2 & my_vec < 6]  # Tra 2 e 6\n#> [1] 3 4 3 3\n```\n:::\n\n\n\n\n### Sostituire elementi in un vettore\n\nPuoi modificare i valori di un vettore usando `[ ]` e l'operatore `<-`.\n\n**Un singolo elemento**:  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[4] <- 500  # Cambia il 4° elemento\nmy_vec\n#> [1]   2   3   1 500   4   3   3   7\n```\n:::\n\n\n\n\n**Più elementi**: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[c(6, 7)] <- 100  # Cambia il 6° e 7° elemento\nmy_vec\n#> [1]   2   3   1 500   4 100 100   7\n```\n:::\n\n\n\n\n**Con condizioni logiche**:  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec[my_vec <= 4] <- 1000  # Cambia valori ≤ 4\nmy_vec\n#> [1] 1000 1000 1000  500 1000  100  100    7\n```\n:::\n\n\n\n\n### Ordinare un vettore\n\n**Dal più piccolo al più grande**:  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_sort <- sort(my_vec)\nvec_sort\n#> [1]    7  100  100  500 1000 1000 1000 1000\n```\n:::\n\n\n\n\n**Dal più grande al più piccolo**:  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_sort2 <- sort(my_vec, decreasing = TRUE)\nvec_sort2\n#> [1] 1000 1000 1000 1000  500  100  100    7\n```\n:::\n\n\n\n\n**Ordinare un vettore in base a un altro**: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheight <- c(180, 155, 160, 167, 181)\np.names <- c(\"Joanna\", \"Charlotte\", \"Helen\", \"Karen\", \"Amy\")\nheight_ord <- order(height)\nnames_ord <- p.names[height_ord]\nnames_ord\n#> [1] \"Charlotte\" \"Helen\"     \"Karen\"     \"Joanna\"    \"Amy\"\n```\n:::\n\n\n\n\n## Operazioni Vettoriali e Vettorizzazione in R\n\nLa vettorializzazione è una delle caratteristiche più potenti di R, che consente di applicare operazioni o funzioni direttamente a tutti gli elementi di un vettore in modo simultaneo, senza dover ricorrere a cicli espliciti. Questo approccio rende il codice più conciso, leggibile ed efficiente, sfruttando al meglio le capacità intrinseche del linguaggio.\n\n### Operazioni Aritmetiche su Vettori\n\nLe operazioni algebriche in R, come addizione, sottrazione, moltiplicazione e divisione, sono vettorizzate. Questo significa che ogni operazione viene applicata \"elemento per elemento\" al vettore.\n\nConsideriamo ad esempio il seguente vettore:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec <- c(3, 5, 7, 1, 9, 20)\n```\n:::\n\n\n\n\nSe vogliamo moltiplicare ciascun elemento di `my_vec` per 5, possiamo scrivere:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec * 5\n#> [1]  15  25  35   5  45 100\n```\n:::\n\n\n\n\nAnalogamente, possiamo effettuare altre operazioni algebriche, come divisione o elevamento a potenza:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec / 2\n#> [1]  1.5  2.5  3.5  0.5  4.5 10.0\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec^2\n#> [1]   9  25  49   1  81 400\n```\n:::\n\n\n\n\nQueste operazioni vengono applicate automaticamente a ciascun elemento del vettore, senza dover iterare su di essi.\n\n### Operazioni Elemento per Elemento tra Due Vettori\n\nLa vettorializzazione consente anche di eseguire operazioni tra due vettori, applicandole elemento per elemento. Supponiamo di avere un secondo vettore:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec2 <- c(17, 15, 13, 19, 11, 0)\n```\n:::\n\n\n\n\nSe vogliamo sommare i due vettori, possiamo scrivere:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec + my_vec2\n#> [1] 20 20 20 20 20 20\n```\n:::\n\n\n\n\nIn questo caso, il primo elemento di `my_vec` viene sommato al primo elemento di `my_vec2`, il secondo elemento al secondo, e così via.\n\n### Attenzione al Riciclo dei Vettori\n\nSe i due vettori hanno lunghezze diverse, R applicherà il meccanismo di **riciclo**: gli elementi del vettore più corto verranno ripetuti ciclicamente per abbinarsi alla lunghezza del vettore più lungo. Questo comportamento, sebbene utile, richiede attenzione per evitare risultati inattesi.\n\nAd esempio:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshort_vec <- c(1, 2)\nmy_vec + short_vec\n#> [1]  4  7  8  3 10 22\n```\n:::\n\n\n\n\nIn questo caso, gli elementi di `short_vec` vengono riciclati per abbinarsi alla lunghezza di `my_vec`. Il risultato è:\n\n```\n(3+1, 5+2, 7+1, 1+2, 9+1, 20+2)\n```\n\n### Applicazione di Funzioni su Vettori\n\nLa vettorializzazione non si limita alle operazioni algebriche, ma si estende anche all'uso di funzioni. Supponiamo di voler calcolare il logaritmo naturale di ciascun elemento di un vettore:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(my_vec)\n#> [1] 1.10 1.61 1.95 0.00 2.20 3.00\n```\n:::\n\n\n\n\nLa funzione `log()` viene applicata automaticamente a ogni elemento del vettore. Analogamente, possiamo utilizzare altre funzioni predefinite di R, come:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(my_vec)  # Calcola la radice quadrata di ciascun elemento\n#> [1] 1.73 2.24 2.65 1.00 3.00 4.47\nexp(my_vec)   # Eleva e alla potenza specificata da ciascun elemento\n#> [1] 2.01e+01 1.48e+02 1.10e+03 2.72e+00 8.10e+03 4.85e+08\n```\n:::\n\n\n\n\nIn conclusione, la vettorializzazione in R rappresenta un approccio elegante ed efficiente per gestire calcoli su vettori. Che si tratti di operazioni algebriche, operazioni tra vettori o applicazione di funzioni, la possibilità di evitare cicli espliciti migliora la leggibilità e la velocità del codice. Tuttavia, è importante prestare attenzione al riciclo dei vettori per evitare errori non intenzionali.\n\n## Gestire dati mancanti (NA)\n\nR rappresenta i dati mancanti con `NA`. La gestione dei dati mancanti dipende dalla funzione utilizzata.\n\n**Calcolo con dati mancanti**:  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- c(7.2, NA, 7.1, 6.9, 6.5, 5.8, 5.8, 5.5, NA, 5.5)\nmean(temp)  # Restituisce NA\n#> [1] NA\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(temp, na.rm = TRUE)  # Ignora i valori mancanti\n#> [1] 6.29\n```\n:::\n\n\n\n\n**Nota**: `na.rm = TRUE` è un argomento comune per ignorare i `NA`, ma non tutte le funzioni lo supportano. Consulta la documentazione della funzione per verificare come gestisce i dati mancanti.\n\nIn conclusione, manipolare vettori è un’abilità essenziale in R. Dalla selezione e modifica degli elementi all’ordinamento e gestione di dati mancanti, queste tecniche sono alla base dell’analisi dei dati in R.\n\n## I dati in R \n\nIn R, i dati possono essere rappresentati in diversi tipi e strutture. Comprendere come gestirli è fondamentale per manipolare, analizzare e riassumere i dataset più complessi.\n\n### Tipi di dati in R\n\nR supporta diversi tipi di dati:\n\n1. **Numeric**: Numeri decimali (es. `2.5`).\n2. **Integer**: Numeri interi (es. `3`).\n3. **Logical**: Valori booleani (`TRUE` o `FALSE`) e `NA` per dati mancanti.\n4. **Character**: Stringhe di testo (es. `\"hello\"`).\n5. **Factor**: Variabili categoriche (es. livelli come `\"low\"`, `\"medium\"`, `\"high\"`).\n\nPuoi verificare il tipo di un oggetto con `class()` e controllare se appartiene a un tipo specifico con funzioni come `is.numeric()`. È anche possibile convertire un tipo in un altro con funzioni come `as.character()`.\n\n### Strutture di dati in R\n\n**Vettori**: Contengono dati dello stesso tipo (es. numeri, stringhe o logici).  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vec <- c(1, 2, 3)\nmy_vec\n#> [1] 1 2 3\n```\n:::\n\n\n\n\n**Matrici e array**: Strutture bidimensionali (matrici) o multidimensionali (array) con dati dello stesso tipo.  \n\nCreare una matrice:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mat <- matrix(1:12, nrow = 3, byrow = TRUE)\nmy_mat\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    2    3    4\n#> [2,]    5    6    7    8\n#> [3,]    9   10   11   12\n```\n:::\n\n\n\n   \nOperazioni utili:\n   \n- **Trasposizione**: `t(my_mat)`\n- **Diagonale**: `diag(my_mat)`\n- **Moltiplicazione matriciale**: `mat1 %*% mat2`\n\n**Liste**: Possono contenere elementi di tipi diversi, inclusi vettori, matrici o altre liste.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(\n  numbers = c(1, 2), \n  text = \"hello\", \n  mat = matrix(1:4, nrow = 2)\n)\nmy_list$numbers  # Accedi agli elementi con il nome\n#> [1] 1 2\n```\n:::\n\n\n\n\n**Data frame**: Strutture bidimensionali che possono contenere colonne di tipi diversi. Ideale per dataset strutturati.  \n\nCreare un data frame:\n   \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheight <- c(180, 155, 160)\nweight <- c(65, 50, 52)\nnames <- c(\"Joanna\", \"Charlotte\", \"Helen\")\n\ndataf <- data.frame(height = height, weight = weight, names = names)\nstr(dataf)  # Mostra la struttura del data frame\n#> 'data.frame':\t3 obs. of  3 variables:\n#>  $ height: num  180 155 160\n#>  $ weight: num  65 50 52\n#>  $ names : chr  \"Joanna\" \"Charlotte\" \"Helen\"\n```\n:::\n\n\n\n\nPer convertire le stringhe in fattori durante la creazione:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndataf <- data.frame(\n  height = height, \n  weight = weight, \n  names = names, \n  stringsAsFactors = TRUE\n)\n\ndataf\n#>   height weight     names\n#> 1    180     65    Joanna\n#> 2    155     50 Charlotte\n#> 3    160     52     Helen\n```\n:::\n\n\n\n\n### Operazioni utili sui data frame\n\n- **Verificare dimensioni**: `dim(dataf)`\n- **Visualizzare struttura**: `str(dataf)`\n- **Accedere a colonne**: `dataf$height`\n\n## Operazioni di Base in R\n\n### Operazioni Aritmetiche  \n\nR supporta le classiche operazioni aritmetiche come somma (`+`), sottrazione (`-`), moltiplicazione (`*`), divisione (`/`) ed esponenziazione (`^`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Somma\n3 + 2\n#> [1] 5\n# Moltiplicazione\n3 * 2\n#> [1] 6\n```\n:::\n\n\n\n\n### Operazioni Logiche  \n\nLe operazioni logiche in R includono:  \n\n- **&**: \"and\" logico  \n- **|**: \"or\" logico  \n- **!**: \"not\" logico  \n- **>**: maggiore di  \n- **<**: minore di  \n- **==**: uguale a  \n- **!=**: diverso da  \n\nEsempi:  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Maggiore di\n3 > 2\n#> [1] TRUE\n# Uguale a\n3 == 2\n#> [1] FALSE\n```\n:::\n\n\n\n\n## Estrazione di Sottoinsiemi di Oggetti in R\n\nIn R esistono tre operatori principali per estrarre sottoinsiemi di oggetti:\n\n1. **Operatore `[ ]`**  \n   Questo operatore restituisce sempre un oggetto della stessa classe dell'originale. È utile per selezionare più elementi da un oggetto. È importante chiudere l'estrazione con `]`.  \n   \n2. **Operatore `[[ ]]`**  \n   Questo operatore viene utilizzato per estrarre elementi da liste o data frame. A differenza di `[ ]`, permette di estrarre un solo elemento alla volta e la classe dell'oggetto restituito non sarà necessariamente una lista o un data frame. L'estrazione va chiusa con `]]`.  \n   \n3. **Operatore `$`**  \n   Come visto in precedenza, questo operatore serve per estrarre elementi da una lista o un data frame utilizzando il loro nome letterale. Il comportamento semantico è simile a quello di `[[ ]]`.\n\n\n### Esempi Pratici\n\nSelezione di colonne in un data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris[, 1:3] |> head()\n#>   Sepal.Length Sepal.Width Petal.Length\n#> 1          5.1         3.5          1.4\n#> 2          4.9         3.0          1.4\n#> 3          4.7         3.2          1.3\n#> 4          4.6         3.1          1.5\n#> 5          5.0         3.6          1.4\n#> 6          5.4         3.9          1.7\n```\n:::\n\n\n\n\nRestituisce le prime tre colonne del dataset `iris`.\n\nSelezione di colonne specifiche per nome:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris[, c('Sepal.Length', 'Petal.Length')] |> \n  head()  # Nomi delle colonne\n#>   Sepal.Length Petal.Length\n#> 1          5.1          1.4\n#> 2          4.9          1.4\n#> 3          4.7          1.3\n#> 4          4.6          1.5\n#> 5          5.0          1.4\n#> 6          5.4          1.7\n```\n:::\n\n\n\n\nSelezione di una singola colonna:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris[, 'Petal.Length'] |> head()\n#> [1] 1.4 1.4 1.3 1.5 1.4 1.7\n```\n:::\n\n\n\n\nSelezione di righe specifiche:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris[c(1, 3), ]\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n```\n:::\n\n\n\n\nRestituisce le righe 1 e 3.\n\nFiltraggio logico di righe:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris[iris$Species == 'versicolor', ] |> head()\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#> 51          7.0         3.2          4.7         1.4 versicolor\n#> 52          6.4         3.2          4.5         1.5 versicolor\n#> 53          6.9         3.1          4.9         1.5 versicolor\n#> 54          5.5         2.3          4.0         1.3 versicolor\n#> 55          6.5         2.8          4.6         1.5 versicolor\n#> 56          5.7         2.8          4.5         1.3 versicolor\n```\n:::\n\n\n\n\nRestituisce le righe con `Species` uguale a \"versicolor\". Numero di righe e colonne del sottoinsieme:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(iris[iris$Species == 'versicolor', ])\n#> [1] 50  5\n```\n:::\n\n\n\n\n### Filtraggio Avanzato con Operatori Logici\n\nGli operatori logici `&` (AND), `|` (OR) e `!` (NOT) permettono un filtraggio più sofisticato.\n\nEsempio: Filtrare le osservazioni di specie \"versicolor\" con lunghezza del sepalo non superiore a 5.0:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris[(iris$Species == 'versicolor') & (iris$Sepal.Length <= 5.0), ]\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n#> 58          4.9         2.4          3.3           1 versicolor\n#> 61          5.0         2.0          3.5           1 versicolor\n#> 94          5.0         2.3          3.3           1 versicolor\n```\n:::\n\n\n\n\nNumero di osservazioni trovate:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(iris[(iris$Species == 'versicolor') & (iris$Sepal.Length <= 5.0), ])\n#> [1] 3 5\n```\n:::\n\n\n\n\n## Riflessioni Conclusive\n\nR non è soltanto un linguaggio di programmazione per la statistica, ma rappresenta una filosofia che si fonda su tre principi chiave: **apertura**, **collaborazione** e **avanzamento della conoscenza scientifica**. \n\nPer chi si avvicina a R, sia nel campo della comunicazione sia in altri ambiti, cogliere questa filosofia è essenziale per apprezzarne appieno il valore. R promuove non solo competenze tecniche, ma anche un impegno verso pratiche di **ricerca trasparente e riproducibile**, che costituiscono un pilastro fondamentale per una scienza rigorosa e affidabile.\n\n**Open Source**  \nR è un software open source, liberamente accessibile a tutti. Questo significa che chiunque può visualizzarne, modificarne e distribuirne il codice sorgente, promuovendo un ambiente trasparente e collaborativo. Essendo gratuito, R garantisce accessibilità a ricercatori di tutto il mondo, indipendentemente dal budget o dal supporto istituzionale. Inoltre, grazie alla sua natura aperta, R beneficia del contributo collettivo di una comunità globale eterogenea.\n\n**Contributi della Comunità**  \nLa comunità di R è uno dei suoi punti di forza principali. Statistici, ricercatori e data scientist di diverse discipline arricchiscono continuamente R sviluppando pacchetti: raccolte di funzioni, dati e codice che ampliano le sue funzionalità. Questa collaborazione ha portato alla creazione di migliaia di pacchetti che coprono tecniche statistiche, metodi grafici e strumenti per la manipolazione dei dati, rendendo R uno strumento sempre più versatile e adatto a un’ampia gamma di esigenze di ricerca.\n\n**Ricerca Riproducibile**  \nLa ricerca riproducibile consiste nel condurre studi in modo tale che altri possano replicarne i risultati utilizzando gli stessi dati e seguendo la stessa metodologia. Questo approccio è cruciale per la validazione delle scoperte scientifiche, permettendo la verifica dei risultati e la costruzione di nuove conoscenze su basi solide.\n\nR facilita la ricerca riproducibile grazie a:  \n\n- Un ecosistema completo di pacchetti per l'analisi dei dati e la generazione di report dinamici.  \n- Strumenti come R Markdown e Quarto, che permettono di integrare testo descrittivo e codice R in un unico documento. Questa integrazione consente di documentare ogni fase del processo di ricerca—dalla pulizia dei dati all’analisi e alla presentazione dei risultati—garantendo trasparenza e replicabilità.  \n\nIn conclusione, comprendere la filosofia open source di R e il suo ruolo nella promozione della ricerca riproducibile fornisce un quadro chiaro del motivo per cui R è diventato uno strumento essenziale per ricercatori e statistici di diverse discipline. Per chi opera in psicologia, sfruttare le potenzialità di R significa produrre risultati di ricerca più trasparenti, replicabili e credibili, contribuendo alla robustezza e affidabilità della conoscenza scientifica nel settore.\n\n## Informazioni sull'Ambiente di Sviluppo {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] viridis_0.6.5     viridisLite_0.4.2 gridExtra_2.3     patchwork_1.3.0  \n#>  [5] bayesplot_1.11.1  psych_2.4.6.26    scales_1.3.0      markdown_1.13    \n#>  [9] knitr_1.49        lubridate_1.9.4   forcats_1.0.0     stringr_1.5.1    \n#> [13] dplyr_1.1.4       purrr_1.0.2       readr_2.1.5       tidyr_1.3.1      \n#> [17] tibble_3.2.1      ggplot2_3.5.1     tidyverse_2.0.0   rio_1.2.3        \n#> [21] here_1.0.1       \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] utf8_1.2.4        generics_0.1.3    stringi_1.8.4     lattice_0.22-6   \n#>  [5] hms_1.1.3         digest_0.6.37     magrittr_2.0.3    evaluate_1.0.1   \n#>  [9] grid_4.4.2        timechange_0.3.0  fastmap_1.2.0     rprojroot_2.0.4  \n#> [13] jsonlite_1.8.9    fansi_1.0.6       mnormt_2.1.1      cli_3.6.3        \n#> [17] rlang_1.1.4       munsell_0.5.1     withr_3.0.2       yaml_2.3.10      \n#> [21] tools_4.4.2       parallel_4.4.2    tzdb_0.4.0        colorspace_2.1-1 \n#> [25] pacman_0.5.1      vctrs_0.6.5       R6_2.5.1          lifecycle_1.0.4  \n#> [29] htmlwidgets_1.6.4 pkgconfig_2.0.3   pillar_1.9.0      gtable_0.3.6     \n#> [33] glue_1.8.0        xfun_0.49         tidyselect_1.2.1  farver_2.1.2     \n#> [37] htmltools_0.5.8.1 nlme_3.1-166      rmarkdown_2.29    compiler_4.4.2\n```\n:::\n\n\n\n\n## Bibliografia {.unnumbered}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}