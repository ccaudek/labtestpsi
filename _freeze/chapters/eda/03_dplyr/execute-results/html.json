{
  "hash": "bb670ff3c54f2458268ba56b73501fa5",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  freeze: auto\n---\n\n\n\n\n# Data wrangling {#sec-dplyr}\n\n**Prerequisiti**\n\n- Leggere [R for Data Science (2e)](https://r4ds.hadley.nz).\n- Consultare [Data cleaning for social scientists](https://bookdown.org/f_lennert/data-prep_2days/).\n\n**Concetti e competenze chiave**\n\n**Preparazione del Notebook**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyr, mice, missForest)\n```\n:::\n\n\n\n\n## Introduzione\n\nL'obiettivo di questo capitolo è fornire un'introduzione alle funzioni principali del linguaggio R per le operazioni di *data wrangling*, cioè per il preprocessing e la pulizia dei dati. In R, queste operazioni sono strettamente legate al concetto di \"data tidying\", che si riferisce all'organizzazione sistematica dei dati per facilitare l'analisi.\n\nPer comprendere meglio il concetto di \"data tidying\", possiamo rifarci a una citazione tratta dal testo di riferimento [*R for Data Science (2e)*](https://r4ds.hadley.nz):\n\n> \"Happy families are all alike; every unhappy family is unhappy in its own way.\"  \n> — Leo Tolstoy\n\n> \"Tidy datasets are all alike, but every messy dataset is messy in its own way.\"  \n> — Hadley Wickham\n\nL'essenza del \"data tidying\" è organizzare i dati in un formato che sia facile da gestire e analizzare. Anche se gli stessi dati possono essere rappresentati in vari modi, non tutte le rappresentazioni sono ugualmente efficienti o facili da usare. Un dataset \"tidy\" segue tre principi fondamentali che lo rendono particolarmente pratico:\n\n1. **Ogni variabile è una colonna**: ogni colonna nel dataset rappresenta una singola variabile.\n2. **Ogni osservazione è una riga**: ogni riga nel dataset rappresenta un'unica osservazione.\n3. **Ogni valore è una cella**: ogni cella del dataset contiene un singolo valore.\n\nI pacchetti R come `dplyr`, `ggplot2` e gli altri pacchetti del tidyverse sono progettati specificamente per lavorare con dati in formato \"tidy\", permettendo agli utenti di eseguire operazioni di manipolazione e visualizzazione in modo più intuitivo ed efficiente.\n\n## Pipe\n\nSia il pacchetto `tidyr` che il pacchetto `dplyr` utilizzano l'operatore pipe, che in R può essere rappresentato da due notazioni principali: `|>` (introdotto nativamente in R a partire dalla versione 4.1.0) e `%>%` (introdotto dal pacchetto `magrittr`, ampiamente utilizzato in `tidyverse`). Entrambi gli operatori permettono di concatenare in modo efficiente una serie di operazioni, ma presentano alcune differenze che meritano attenzione.\n\n### Cosa Fa la Pipe?\n\nLa pipe è uno strumento potente che permette di collegare in modo diretto l'output di una funzione come input della funzione successiva. Questo approccio:\n\n- Riduce la necessità di creare variabili intermedie.\n- Migliora la leggibilità del codice.\n- Rende il flusso delle operazioni più chiaro e lineare.\n\nOgni funzione applicata con la pipe riceve automaticamente l'output della funzione precedente come suo primo argomento. Ciò consente di scrivere sequenze di operazioni in un formato compatto e intuitivo.\n\nEcco un esempio pratico:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Utilizzo della pipe per trasformare un dataset\nlibrary(dplyr)\n\ndf <- data.frame(\n  id = 1:5,\n  value = c(10, 20, 30, 40, 50)\n)\n\n# Filtra i dati, seleziona colonne e calcola nuovi valori\ndf_clean <- df |>\n  dplyr::filter(value > 20) |>\n  dplyr::select(id, value) |>\n  mutate(squared_value = value^2)\n```\n:::\n\n\n\n\nIn questa sequenza, il dataset originale `df` viene filtrato, le colonne desiderate vengono selezionate e viene aggiunta una nuova colonna con il valore al quadrato.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df_clean)\n#>   id value squared_value\n#> 1  3    30           900\n#> 2  4    40          1600\n#> 3  5    50          2500\n```\n:::\n\n\n\n\nIn sintesi, la pipe è uno strumento fondamentale per scrivere codice R moderno e leggibile, indipendentemente dal fatto che si utilizzi `|>` o `%>%`. \n\n## Verbi\n\nLe funzioni principali (\"verbi) di `dplyr` sono le seguenti:\n\n| Verbo dplyr  | Descrizione                                               |\n|--------------|-----------------------------------------------------------|\n| `select()`   | Seleziona colonne                                          |\n| `filter()`   | Filtra righe                                               |\n| `arrange()`  | Riordina o organizza le righe                              |\n| `mutate()`   | Crea nuove colonne                                         |\n| `summarise()`| Riassume i valori                                          |\n| `group_by()` | Consente di eseguire operazioni di gruppo                  |\n\nI verbi di `dplyr` sono suddivisi in quattro gruppi, in base all'elemento su cui operano: righe, colonne, gruppi o tabelle.\n\nInoltre, le diverse funzioni `bind_` e `_joins` permettono di combinare più tibbles (ovvero, data frame) in uno solo.\n\nPer introdurre il processo di \"data tidying\", in questo tutorial utilizzeremo il dataset `msleep`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(msleep)\ndim(msleep)\n#> [1] 83 11\n```\n:::\n\n\n\n\nEsaminiamo i dati:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(msleep)\n#> Rows: 83\n#> Columns: 11\n#> $ name         <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater s…\n#> $ genus        <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bos\", \"…\n#> $ vore         <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi\", \"c…\n#> $ order        <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorpha\", \"…\n#> $ conservation <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", NA, \"d…\n#> $ sleep_total  <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0…\n#> $ sleep_rem    <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.…\n#> $ sleep_cycle  <dbl> NA, NA, NA, 0.133, 0.667, 0.767, 0.383, NA, 0.333, NA,…\n#> $ awake        <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9, 21.0…\n#> $ brainwt      <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000…\n#> $ bodywt       <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0…\n```\n:::\n\n\n\n\nLe colonne, nell'ordine, corrispondono a quanto segue:\n\n| Nome colonna   | Descrizione                                     |\n|----------------|-------------------------------------------------|\n| name           | Nome comune                                     |\n| genus          | Rango tassonomico                               |\n| vore           | Carnivoro, onnivoro o erbivoro?                 |\n| order          | Rango tassonomico                               |\n| conservation   | Stato di conservazione del mammifero            |\n| sleep_total    | Quantità totale di sonno, in ore                |\n| sleep_rem      | Sonno REM, in ore                               |\n| sleep_cycle    | Durata del ciclo di sonno, in ore               |\n| awake          | Quantità di tempo trascorso sveglio, in ore     |\n| brainwt        | Peso del cervello, in chilogrammi               |\n| bodywt         | Peso corporeo, in chilogrammi                   |\n\n## Righe\n\nI verbi più importanti che operano sulle righe di un dataset sono `filter()`, che seleziona le righe da includere senza modificarne l'ordine, e `arrange()`, che cambia l'ordine delle righe senza alterare la selezione delle righe presenti.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmsleep |>\n    dplyr::filter(sleep_total < 4) |>\n    arrange(sleep_total)\n#> # A tibble: 9 × 11\n#>   name            genus         vore  order          conservation sleep_total\n#>   <chr>           <chr>         <chr> <chr>          <chr>              <dbl>\n#> 1 Giraffe         Giraffa       herbi Artiodactyla   cd                   1.9\n#> 2 Pilot whale     Globicephalus carni Cetacea        cd                   2.7\n#> 3 Horse           Equus         herbi Perissodactyla domesticated         2.9\n#> 4 Roe deer        Capreolus     herbi Artiodactyla   lc                   3  \n#> 5 Donkey          Equus         herbi Perissodactyla domesticated         3.1\n#> 6 African elepha… Loxodonta     herbi Proboscidea    vu                   3.3\n#> # ℹ 3 more rows\n#> # ℹ 5 more variables: sleep_rem <dbl>, sleep_cycle <dbl>, awake <dbl>, …\n```\n:::\n\n\n\n\nPossiamo usare `filter()` speficicano più di una condizione logica.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmsleep |>\n    dplyr::filter((sleep_total < 4 & bodywt > 100) | brainwt > 1) |>\n    arrange(sleep_total)\n#> # A tibble: 7 × 11\n#>   name            genus         vore  order          conservation sleep_total\n#>   <chr>           <chr>         <chr> <chr>          <chr>              <dbl>\n#> 1 Giraffe         Giraffa       herbi Artiodactyla   cd                   1.9\n#> 2 Pilot whale     Globicephalus carni Cetacea        cd                   2.7\n#> 3 Horse           Equus         herbi Perissodactyla domesticated         2.9\n#> 4 Donkey          Equus         herbi Perissodactyla domesticated         3.1\n#> 5 African elepha… Loxodonta     herbi Proboscidea    vu                   3.3\n#> 6 Asian elephant  Elephas       herbi Proboscidea    en                   3.9\n#> # ℹ 1 more row\n#> # ℹ 5 more variables: sleep_rem <dbl>, sleep_cycle <dbl>, awake <dbl>, …\n```\n:::\n\n\n\n\n## Colonne\n\nEsistono quattro verbi principali che modificano le colonne di un dataset senza cambiare le righe:\n\n- `relocate()` cambia la posizione delle colonne;\n- `rename()` modifica i nomi delle colonne;\n- `select()` seleziona le colonne da includere o escludere;\n- `mutate()` crea nuove colonne a partire da quelle esistenti.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmsleep2 <- msleep |>\n    mutate(\n        rem_prop = sleep_rem / sleep_total * 100\n    ) |>\n    dplyr::select(name, vore, rem_prop, sleep_total) |>\n    arrange(desc(rem_prop))\n\nglimpse(msleep2)\n#> Rows: 83\n#> Columns: 4\n#> $ name        <chr> \"European hedgehog\", \"Thick-tailed opposum\", \"Giant arm…\n#> $ vore        <chr> \"omni\", \"carni\", \"insecti\", \"omni\", \"carni\", \"omni\", \"o…\n#> $ rem_prop    <dbl> 34.7, 34.0, 33.7, 29.2, 28.7, 27.2, 26.4, 26.2, 25.6, 2…\n#> $ sleep_total <dbl> 10.1, 19.4, 18.1, 8.9, 10.1, 18.0, 9.1, 10.3, 12.5, 8.4…\n```\n:::\n\n\n\n\nIn questo esempio, utilizziamo `mutate()` per creare una nuova colonna `rem_prop` che rappresenta la percentuale di sonno REM sul totale del sonno. Successivamente, `select()` viene utilizzato per scegliere solo alcune colonne del dataset, e infine `desc(rem_prop)` ordina i valori di `rem_prop` in ordine decrescente, dal valore maggiore a quello minore.\n\nPer cambiare il nome di una colonna possiamo usare `rename()`. Inoltre, possiamo cambiare l'ordine delle variabili con `relocate()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmsleep2 |>\n    rename(rem_perc = rem_prop) |>\n    relocate(rem_perc, .before = name)\n#> # A tibble: 83 × 4\n#>   rem_perc name                   vore    sleep_total\n#>      <dbl> <chr>                  <chr>         <dbl>\n#> 1     34.7 European hedgehog      omni           10.1\n#> 2     34.0 Thick-tailed opposum   carni          19.4\n#> 3     33.7 Giant armadillo        insecti        18.1\n#> 4     29.2 Tree shrew             omni            8.9\n#> 5     28.7 Dog                    carni          10.1\n#> 6     27.2 North American Opossum omni           18  \n#> # ℹ 77 more rows\n```\n:::\n\n\n\n\n## Gruppi\n\nIl verbo `group_by()` viene utilizzato per suddividere un dataset in gruppi, in base a una o più variabili, che siano rilevanti per l'analisi. Questo permette di eseguire operazioni di sintesi su ciascun gruppo separatamente, ottenendo informazioni aggregate.\n\nAd esempio, nel codice seguente:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmsleep |>\n    group_by(order) |>\n    summarise(\n        avg_sleep = mean(sleep_total),\n        min_sleep = min(sleep_total),\n        max_sleep = max(sleep_total),\n        total = n()\n    ) |>\n    arrange(desc(avg_sleep))\n#> # A tibble: 19 × 5\n#>   order           avg_sleep min_sleep max_sleep total\n#>   <chr>               <dbl>     <dbl>     <dbl> <int>\n#> 1 Chiroptera           19.8      19.7      19.9     2\n#> 2 Didelphimorphia      18.7      18        19.4     2\n#> 3 Cingulata            17.8      17.4      18.1     2\n#> 4 Afrosoricida         15.6      15.6      15.6     1\n#> 5 Pilosa               14.4      14.4      14.4     1\n#> 6 Rodentia             12.5       7        16.6    22\n#> # ℹ 13 more rows\n```\n:::\n\n\n\n\n1. `group_by(order)` suddivide il dataset `msleep` in gruppi, ciascuno corrispondente a un valore distinto della variabile `order`.\n  \n2. Successivamente, `summarise()` calcola diverse statistiche per ogni gruppo:\n   - `avg_sleep` è la media del totale del sonno (`sleep_total`) all'interno di ciascun gruppo.\n   - `min_sleep` è il valore minimo di `sleep_total` in ogni gruppo.\n   - `max_sleep` è il valore massimo di `sleep_total` in ogni gruppo.\n   - `total` è il numero di osservazioni (o righe) per ciascun gruppo, calcolato con la funzione `n()`.\n\n3. Infine, `arrange(desc(avg_sleep))` ordina i risultati in ordine decrescente in base alla media del sonno totale (`avg_sleep`), mostrando prima i gruppi con la media di sonno più alta. \n\nQuesto tipo di approccio è utile quando si vuole analizzare come cambiano le caratteristiche dei dati a seconda dei gruppi specifici, fornendo una visione più dettagliata e significativa.\n\n## Dati mancanti\n\nNel dataset ci sono celle che contengono valori mancanti, indicati come NA. Questi rappresentano misurazioni per le quali i dati non sono stati registrati.\n\nPer ottenere una panoramica dei dati, inclusi i valori mancanti, possiamo utilizzare il comando:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(msleep)\n#>      name              genus               vore              order          \n#>  Length:83          Length:83          Length:83          Length:83         \n#>  Class :character   Class :character   Class :character   Class :character  \n#>  Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>  conservation        sleep_total      sleep_rem     sleep_cycle \n#>  Length:83          Min.   : 1.90   Min.   :0.10   Min.   :0.1  \n#>  Class :character   1st Qu.: 7.85   1st Qu.:0.90   1st Qu.:0.2  \n#>  Mode  :character   Median :10.10   Median :1.50   Median :0.3  \n#>                     Mean   :10.43   Mean   :1.88   Mean   :0.4  \n#>                     3rd Qu.:13.75   3rd Qu.:2.40   3rd Qu.:0.6  \n#>                     Max.   :19.90   Max.   :6.60   Max.   :1.5  \n#>                                     NA's   :22     NA's   :51   \n#>      awake         brainwt         bodywt    \n#>  Min.   : 4.1   Min.   :0.00   Min.   :   0  \n#>  1st Qu.:10.2   1st Qu.:0.00   1st Qu.:   0  \n#>  Median :13.9   Median :0.01   Median :   2  \n#>  Mean   :13.6   Mean   :0.28   Mean   : 166  \n#>  3rd Qu.:16.1   3rd Qu.:0.13   3rd Qu.:  42  \n#>  Max.   :22.1   Max.   :5.71   Max.   :6654  \n#>                 NA's   :27\n```\n:::\n\n\n\n\nPer visualizzare il pattern di dati mancanti, ovvero come la mancanza di una variabile possa influenzare la mancanza di altre, si può usare:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmd.pattern(msleep, rotate.names = TRUE)\n#>    name genus order sleep_total awake bodywt vore sleep_rem brainwt\n#> 20    1     1     1           1     1      1    1         1       1\n#> 9     1     1     1           1     1      1    1         1       1\n#> 9     1     1     1           1     1      1    1         1       1\n#> 5     1     1     1           1     1      1    1         1       1\n#> 1     1     1     1           1     1      1    1         1       0\n#> 10    1     1     1           1     1      1    1         1       0\n#> 1     1     1     1           1     1      1    1         1       0\n#> 1     1     1     1           1     1      1    1         1       0\n#> 5     1     1     1           1     1      1    1         0       1\n#> 3     1     1     1           1     1      1    1         0       1\n#> 7     1     1     1           1     1      1    1         0       0\n#> 5     1     1     1           1     1      1    1         0       0\n#> 2     1     1     1           1     1      1    0         1       1\n#> 1     1     1     1           1     1      1    0         1       1\n#> 2     1     1     1           1     1      1    0         1       1\n#> 2     1     1     1           1     1      1    0         0       0\n#>       0     0     0           0     0      0    7        22      27\n#>    conservation sleep_cycle    \n#> 20            1           1   0\n#> 9             1           0   1\n#> 9             0           1   1\n#> 5             0           0   2\n#> 1             1           1   1\n#> 10            1           0   2\n#> 1             0           1   2\n#> 1             0           0   3\n#> 5             1           0   2\n#> 3             0           0   3\n#> 7             1           0   3\n#> 5             0           0   4\n#> 2             1           0   2\n#> 1             0           1   2\n#> 2             0           0   3\n#> 2             0           0   5\n#>              29          51 136\n```\n\n::: {.cell-output-display}\n![](03_dplyr_files/figure-html/unnamed-chunk-12-1.png){width=576}\n:::\n:::\n\n\n\n\nIl modo più semplice per gestire i valori mancanti è l'analisi dei casi completi (*complete case analysis*), che esclude dall'analisi le osservazioni con valori mancanti e utilizza solo quelle con tutte le variabili registrate. Questo approccio può essere implementato come segue:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmsleep_comp <- msleep |>\n    drop_na()\ndim(msleep_comp)\n#> [1] 20 11\n```\n:::\n\n\n\n\nTuttavia, per il dataset in questione, questa strategia non è adeguata, poiché si passa da 83 osservazioni iniziali a solo 20 righe dopo aver eliminato i dati mancanti.\n\nUn approccio più utile è l'utilizzo di metodi di imputazione (*imputation methods*). Uno di questi è l'imputazione semplice (*single imputation*, SI), dove il valore mancante viene sostituito dalla media della variabile corrispondente. Questo tipo di imputazione può essere eseguito come segue:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimp <- mice(msleep, method = \"mean\", m = 1, maxit = 1, print = FALSE)\n#> Warning: Number of logged events: 6\ncomplete(imp) |>\n    summary()\n#>      name              genus               vore              order          \n#>  Length:83          Length:83          Length:83          Length:83         \n#>  Class :character   Class :character   Class :character   Class :character  \n#>  Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>  conservation        sleep_total      sleep_rem     sleep_cycle   \n#>  Length:83          Min.   : 1.90   Min.   :0.10   Min.   :0.117  \n#>  Class :character   1st Qu.: 7.85   1st Qu.:1.15   1st Qu.:0.417  \n#>  Mode  :character   Median :10.10   Median :1.88   Median :0.440  \n#>                     Mean   :10.43   Mean   :1.88   Mean   :0.440  \n#>                     3rd Qu.:13.75   3rd Qu.:2.20   3rd Qu.:0.440  \n#>                     Max.   :19.90   Max.   :6.60   Max.   :1.500  \n#>      awake         brainwt         bodywt    \n#>  Min.   : 4.1   Min.   :0.00   Min.   :   0  \n#>  1st Qu.:10.2   1st Qu.:0.01   1st Qu.:   0  \n#>  Median :13.9   Median :0.12   Median :   2  \n#>  Mean   :13.6   Mean   :0.28   Mean   : 166  \n#>  3rd Qu.:16.1   3rd Qu.:0.28   3rd Qu.:  42  \n#>  Max.   :22.1   Max.   :5.71   Max.   :6654\n```\n:::\n\n\n\n\nTuttavia, uno dei problemi dell'imputazione media è che tende a ridurre la varianza e a rendere le stime dell'errore standard meno accurate, generando bias verso il basso.\n\nUn metodo più sofisticato è l'imputazione multipla (*multiple imputation*, MI). Questa tecnica genera più imputazioni, creando diversi dataset completi. Per ciascuno di questi dataset, è possibile effettuare l'analisi desiderata e, al termine, combinare i risultati ottenuti dai vari dataset imputati per ottenere un risultato finale più robusto. Un esempio di questa tecnica utilizza il metodo di predictive mean matching (metodo = \"pmm\"), che sfrutta i valori vicini nei dati come imputazioni:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimp2 <- mice(msleep, method = \"pmm\", m = 1, maxit = 100, print = FALSE)\n#> Warning: Number of logged events: 6\ncomplete(imp2) |>\n    summary()\n#>      name              genus               vore              order          \n#>  Length:83          Length:83          Length:83          Length:83         \n#>  Class :character   Class :character   Class :character   Class :character  \n#>  Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>  conservation        sleep_total      sleep_rem     sleep_cycle   \n#>  Length:83          Min.   : 1.90   Min.   :0.10   Min.   :0.117  \n#>  Class :character   1st Qu.: 7.85   1st Qu.:0.90   1st Qu.:0.183  \n#>  Mode  :character   Median :10.10   Median :1.50   Median :0.333  \n#>                     Mean   :10.43   Mean   :1.84   Mean   :0.450  \n#>                     3rd Qu.:13.75   3rd Qu.:2.40   3rd Qu.:0.667  \n#>                     Max.   :19.90   Max.   :6.60   Max.   :1.500  \n#>      awake         brainwt         bodywt    \n#>  Min.   : 4.1   Min.   :0.00   Min.   :   0  \n#>  1st Qu.:10.2   1st Qu.:0.00   1st Qu.:   0  \n#>  Median :13.9   Median :0.01   Median :   2  \n#>  Mean   :13.6   Mean   :0.24   Mean   : 166  \n#>  3rd Qu.:16.1   3rd Qu.:0.14   3rd Qu.:  42  \n#>  Max.   :22.1   Max.   :5.71   Max.   :6654\n```\n:::\n\n\n\n\nL'imputazione multipla, grazie alla sua capacità di considerare la variabilità tra le diverse imputazioni, fornisce stime più accurate rispetto all'imputazione media semplice, riducendo il rischio di bias e fornendo risultati più affidabili.\n\n## Considerazioni Conclusive\n\nIl *data wrangling* è una delle fasi più importanti in qualsiasi pipeline di analisi dei dati. In questo capitolo abbiamo introdotto l'uso del pacchetto `tidyverse` di R per la manipolazione dei dati e il suo utilizzo in scenari di base. Tuttavia, il tidyverse è un ecosistema ampio e qui abbiamo trattato solo gli elementi fondamentali. Per approfondire, si consiglia di consultare ulteriori risorse come quelle disponibili sul sito web del tidyverse e il libro [*R for Data Science (2e)*](https://r4ds.hadley.nz), di cui esiste anche una [traduzione italiana](https://it.r4ds.hadley.nz).\n\n## Informazioni sull'Ambiente di Sviluppo {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] missForest_1.5    mice_3.17.0       viridis_0.6.5     viridisLite_0.4.2\n#>  [5] gridExtra_2.3     patchwork_1.3.0   bayesplot_1.11.1  psych_2.4.6.26   \n#>  [9] scales_1.3.0      markdown_1.13     knitr_1.49        lubridate_1.9.4  \n#> [13] forcats_1.0.0     stringr_1.5.1     dplyr_1.1.4       purrr_1.0.2      \n#> [17] readr_2.1.5       tidyr_1.3.1       tibble_3.2.1      ggplot2_3.5.1    \n#> [21] tidyverse_2.0.0   rio_1.2.3         here_1.0.1       \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] tidyselect_1.2.1     farver_2.1.2         fastmap_1.2.0       \n#>  [4] pacman_0.5.1         digest_0.6.37        rpart_4.1.23        \n#>  [7] timechange_0.3.0     lifecycle_1.0.4      survival_3.7-0      \n#> [10] magrittr_2.0.3       compiler_4.4.2       rlang_1.1.4         \n#> [13] rngtools_1.5.2       tools_4.4.2          utf8_1.2.4          \n#> [16] yaml_2.3.10          doRNG_1.8.6          htmlwidgets_1.6.4   \n#> [19] mnormt_2.1.1         withr_3.0.2          itertools_0.1-3     \n#> [22] nnet_7.3-19          grid_4.4.2           fansi_1.0.6         \n#> [25] jomo_2.7-6           colorspace_2.1-1     iterators_1.0.14    \n#> [28] MASS_7.3-61          cli_3.6.3            rmarkdown_2.29      \n#> [31] generics_0.1.3       tzdb_0.4.0           minqa_1.2.8         \n#> [34] splines_4.4.2        parallel_4.4.2       vctrs_0.6.5         \n#> [37] boot_1.3-31          glmnet_4.1-8         Matrix_1.7-1        \n#> [40] jsonlite_1.8.9       hms_1.1.3            mitml_0.4-5         \n#> [43] foreach_1.5.2        glue_1.8.0           nloptr_2.1.1        \n#> [46] pan_1.9              codetools_0.2-20     stringi_1.8.4       \n#> [49] shape_1.4.6.1        gtable_0.3.6         lme4_1.1-35.5       \n#> [52] munsell_0.5.1        pillar_1.9.0         htmltools_0.5.8.1   \n#> [55] randomForest_4.7-1.2 R6_2.5.1             rprojroot_2.0.4     \n#> [58] evaluate_1.0.1       lattice_0.22-6       backports_1.5.0     \n#> [61] broom_1.0.7          Rcpp_1.0.13-1        nlme_3.1-166        \n#> [64] xfun_0.49            pkgconfig_2.0.3\n```\n:::",
    "supporting": [
      "03_dplyr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}