{
  "hash": "f0c813729812256997c98cd09ee5468b",
  "result": {
    "engine": "knitr",
    "markdown": "# Esplorare i dati numerici {#sec-eda-exploring-num-data}\n\n::: callout-note\n## In questo capitolo imparerai a\n\n- costruire e interpretare distribuzioni di frequenza;\n- rappresentare e comprendere istogrammi tradizionali e “lisciati”;\n- realizzare e interpretare boxplot e violin plot.\n:::\n\n::: callout-tip\n## Prerequisiti\n\n- Leggere l'Appendice @sec-apx-sums prima di procedere con la lettura di questo capitolo.\n- Leggere il capitolo [Exploring numerical data](https://openintro-ims.netlify.app/explore-numerical) di [Introduction to Modern Statistics (2e)](https://openintro-ims.netlify.app) di Mine Çetinkaya-Rundel e Johanna Hardin.\n:::\n\n::: callout-important\n## Preparazione del Notebook\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(ggbeeswarm)\n```\n:::\n\n\n\n\n:::\n\n## Introduzione {.unnumbered}\n\nIn questo capitolo ci concentreremo sull'analisi dei dati numerici. In particolare, esamineremo le distribuzioni di frequenza e i quantili, insieme alle tecniche di visualizzazione più comuni, come l'istogramma, l'istogramma smussato e il box-plot. Tratteremo sia gli aspetti computazionali che quelli interpretativi di queste misure, fornendo strumenti utili non solo per una comprensione personale, ma anche per la comunicazione efficace dei risultati, in particolare con chi utilizza questi dati per prendere decisioni pratiche nel mondo reale.\n\n## I dati sulle aspettative negative nella depressione\n\nConsideriamo i dati relativi alle aspettative negative, individuate come un meccanismo chiave nel mantenimento della depressione [@zetsche_2019future]. Supponiamo di voler analizzare la distribuzione di una singola variabile quantitativa.\n\nImportiamo i dati:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf = rio::import(here::here(\"data\", \"data.mood.csv\"))\n```\n:::\n\n\n\n\n\nPer questo esercizio, ci concentreremo sulle colonne `esm_id` (il codice del soggetto), `group` (il gruppo) e `bdi` (il valore BDI-II).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df |> \n  dplyr::select(\"esm_id\", \"group\", \"bdi\")\ndf |> \n  head()\n#>   esm_id group bdi\n#> 1     10   mdd  25\n#> 2     10   mdd  25\n#> 3     10   mdd  25\n#> 4     10   mdd  25\n#> 5     10   mdd  25\n#> 6     10   mdd  25\n```\n:::\n\n\n\n\n\nSe elenchiamo le modalità presenti in `group` utilizzando il metodo `unique()`, scopriamo che corrispondono a `mdd` (pazienti) e `ctl` (controlli sani).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$group |> \n  unique()\n#> [1] \"mdd\" \"ctl\"\n```\n:::\n\n\n\n\n\nRimuoviamo i duplicati per ottenere un unico valore BDI-II per ogni soggetto:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df[!duplicated(df), ]\n```\n:::\n\n\n\n\n\nVerifichiamo di avere ottenuto il risultato desiderato.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(df)\n#> [1] 67  3\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df)\n#>    esm_id group bdi\n#> 1      10   mdd  25\n#> 15      9   mdd  30\n#> 30      6   mdd  26\n#> 46      7   mdd  35\n#> 65     12   mdd  44\n#> 83     16   mdd  30\n```\n:::\n\n\n\n\n\nSi noti che il nuovo DataFrame (con 67 righe) conserva il \"nome\" delle righe (ovvero, l'indice di riga) del DataFrame originario (con 1188 righe). Per esempio, il secondo soggetto (con codice identificativo 9) si trova sulla seconda riga del DataFrame, ma il suo indice di riga è 15. Questo non ha nessuna conseguenza perché non useremo l'indice di riga nelle analisi seguenti.\n\nEliminiamo eventuali valori mancanti:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df[!is.na(df$bdi), ]\n```\n:::\n\n\n\n\n\nOtteniamo così il DataFrame finale per gli scopi presenti (66 righe e 3 colonne):\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(df)\n#> [1] 66  3\n```\n:::\n\n\n\n\n\nStampiamo i valori BDI-II presentandoli ordinati dal più piccolo al più grande:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$bdi |> \n  sort()\n#>  [1]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1\n#> [25]  1  2  2  2  2  3  3  3  5  7  9 12 19 22 22 24 25 25 26 26 26 27 27 28\n#> [49] 28 30 30 30 31 31 33 33 34 35 35 35 36 39 41 43 43 44\n```\n:::\n\n\n\n\n\nNel linguaggio statistico, un'osservazione rappresenta l'informazione raccolta da un singolo individuo o entità che partecipa allo studio. Nel caso del dataset utilizzato da @zetsche_2019future, l'unità di osservazione è costituita dai partecipanti allo studio. Ogni riga del DataFrame, denominato `df`, corrisponde quindi a un individuo distinto incluso nell'analisi.\n\nLe variabili, invece, riflettono le diverse caratteristiche degli individui o delle entità considerate. Per i dati in esame, questo concetto si esprime così:\n\n- Ogni colonna di `df` rappresenta una variabile che descrive una specifica proprietà comune ai partecipanti.\n- Le variabili sono identificate da etichette nelle colonne, come `esa_id` (l'identificativo del soggetto), `mdd` (il gruppo di appartenenza), e `bdi` (il punteggio del test BDI-II).\n\nIn termini simbolisi, per indicare una singola osservazione della variabile generica $X$, si utilizza la notazione $X_i$, dove $i$ rappresenta l'indice dell'osservazione. Questo implica che abbiamo un valore diverso di $X$ per ogni differente $i$. Nel caso presente, con 67 osservazioni, $i$ varia da 1 a 67. Così, per rappresentare la seconda osservazione (quella con $i=2$), useremo la notazione $X_2$. \n\n## Distribuzioni di frequenza\n\nCome osservato nell'output della sezione precedente, i dati grezzi non forniscono un'interpretazione immediata. Per rendere i dati più comprensibili e sintetici, è utile costruire una distribuzione di frequenza.\n\nUna distribuzione di frequenza mostra quante volte i valori di una variabile si verificano all'interno di intervalli specifici. Nel caso dei punteggi BDI-II, possiamo raggruppare i punteggi in quattro classi:\n\n- 0–13: depressione minima\n- 14–19: depressione lieve-moderata\n- 20–28: depressione moderata-severa\n- 29–63: depressione severa\n\nOgni classe, denotata come $\\Delta_i$, rappresenta un intervallo di valori, definito come $[a_i, b_i)$ (aperto a destra) o $(a_i, b_i]$ (aperto a sinistra), dove $a_i$ e $b_i$ sono rispettivamente il limite inferiore e superiore della classe. A ciascuna classe si associa un'ampiezza, data da $b_i - a_i$, e un valore centrale, indicato con $\\bar{x}_i$. Poiché ogni osservazione $x_i$ appartiene a una sola classe $\\Delta_i$, possiamo calcolare le seguenti quantità:\n\n- **Frequenza assoluta** $n_i$: il numero di osservazioni che rientrano nella classe $\\Delta_i$.\n  - Proprietà: $n_1 + n_2 + \\dots + n_m = n$, dove $n$ è il numero totale di osservazioni.\n  \n- **Frequenza relativa** $f_i$: la proporzione di osservazioni in ciascuna classe, calcolata come $f_i = n_i/n$.\n  - Proprietà: $f_1 + f_2 + \\dots + f_m = 1$.\n\n- **Frequenza cumulata** $N_i$: il numero totale di osservazioni che rientrano nelle classi fino alla $i$-esima inclusa, calcolata come $N_i = \\sum_{j=1}^i n_j$.\n\n- **Frequenza cumulata relativa** $F_i$: la somma delle frequenze relative fino alla $i$-esima classe, data da $F_i = \\frac{N_i}{n} = \\sum_{j=1}^i f_j$.\n\nQueste misure permettono di riassumere in modo efficace la distribuzione dei punteggi e facilitano l'interpretazione delle caratteristiche del campione.\n\n### Frequenze Assolute e Relative\n\nPer ottenere la distribuzione di frequenza assoluta e relativa dei valori BDI-II nel dataset di `zetsche_2019future`, è necessario aggiungere al DataFrame `df` una colonna contenente una variabile categoriale che classifichi ciascuna osservazione in una delle quattro classi che descrivono la gravità della depressione. Questo risultato si ottiene utilizzando la funzione `cut()`.\n\nNella funzione `cut()`:\n\n- Il primo argomento, `x`, è un vettore unidimensionale (ad esempio, un vettore di tipo `numeric` o una colonna di un DataFrame) che contiene i dati da classificare.\n- Il secondo argomento, `breaks`, definisce gli intervalli delle classi, specificandone i limiti inferiori e superiori.\n- L'argomento `include.lowest = TRUE` garantisce che il limite inferiore dell'intervallo più basso sia incluso nella classificazione. Nel nostro caso, questo è particolarmente utile per assicurare che i valori uguali al limite inferiore siano assegnati correttamente.\n\nDi seguito, il codice per aggiungere la variabile categoriale al DataFrame:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creare una variabile categoriale per classi di depressione\ndf <- df %>% \n  mutate(\n    bdi_class = cut(\n      bdi, \n      breaks = c(0, 13.5, 19.5, 28.5, 63),\n      include.lowest = TRUE\n    )\n  )\n```\n:::\n\n\n\n\n\nQuesto codice suddivide i valori della variabile `bdi` in quattro intervalli corrispondenti ai livelli di gravità della depressione: \n\n- 0–13: depressione minima\n- 14–19: depressione lieve-moderata\n- 20–28: depressione moderata-severa\n- 29–63: depressione severa\n\nOgni osservazione verrà assegnata al corrispondente intervallo, creando così una nuova colonna `bdi_class` nel DataFrame `df`.\n\n#### Frequenze assolute\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df$bdi_class)\n#> \n#>    [0,13.5] (13.5,19.5] (19.5,28.5]   (28.5,63] \n#>          36           1          12          17\n```\n:::\n\n\n\n\n\n#### Frequenze relative\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(table(df$bdi_class))\n#> \n#>    [0,13.5] (13.5,19.5] (19.5,28.5]   (28.5,63] \n#>      0.5455      0.0152      0.1818      0.2576\n```\n:::\n\n\n\n\n\n### Distribuzioni congiunte\n\nLe variabili possono anche essere analizzate insieme tramite le *distribuzioni congiunte di frequenze*. Queste distribuzioni rappresentano l'insieme delle frequenze assolute o relative ad ogni possibile combinazione di valori delle variabili. Ad esempio, se l'insieme di variabili $V$ è composto da due variabili, $X$ e $Y$, ciascuna delle quali può assumere due valori, 1 e 2, allora una possibile distribuzione congiunta di frequenze relative per $V$ potrebbe essere espressa come $f(X = 1, Y = 1) = 0.2$, $f(X = 1, Y = 2) = 0.1$, $f(X = 2, Y = 1) = 0.5$, e $f(X = 2, Y = 2) = 0.2$. Come nel caso delle distribuzioni di frequenze relative di una singola variabile, le frequenze relative di una distribuzione congiunta devono sommare a 1.\n\nPer i dati dell'esempio precedente, la funzione `prop.table()` può essere utilizzata anche per produrre questo tipo di tabella: basta indicare le serie corrispondenti alle variabili considerate come valori degli argomenti `bdi_class` e `group`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(table(df$bdi_class, df$group))\n#>              \n#>                  ctl    mdd\n#>   [0,13.5]    0.5455 0.0000\n#>   (13.5,19.5] 0.0000 0.0152\n#>   (19.5,28.5] 0.0000 0.1818\n#>   (28.5,63]   0.0000 0.2576\n```\n:::\n\n\n\n\n\n## Istogramma\n\nUn istogramma rappresenta graficamente una distribuzione di frequenze. Un istogramma mostra sulle ascisse i limiti delle classi $\\Delta_i$ e sulle ordinate la densità della frequenza relativa della variabile $X$ nella classe $\\Delta_i$. La densità della frequenza relativa è misurata dalla funzione costante a tratti $\\varphi_n(x)= \\frac{f_i}{b_i-a_i}$, dove $f_i$ è la frequenza relativa della classe $\\Delta_i$ e $b_i - a_i$ rappresenta l'ampiezza della classe. In questo modo, l'area del rettangolo associato alla classe $\\Delta_i$ sull'istogramma sarà proporzionale alla frequenza relativa $f_i$. È importante notare che l'area totale dell'istogramma delle frequenze relative è uguale a 1.0, poiché rappresenta la somma delle aree dei singoli rettangoli. \n\nPer fare un esempio, costruiamo un istogramma per i valori BDI-II di @zetsche_2019future. Con i quattro intervalli individuati dai cut-off del BDI-II creo una prima versione dell'istogramma -- si notino le frequenze assolute sull'asse delle ordinate.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = bdi)) +\n  geom_histogram(\n    breaks = c(0, 13.5, 19.5, 28.5, 63),\n    aes(y = ..density..),\n    alpha = 0.5\n  ) +\n  labs(\n    title = \"Istogramma delle frequenze relative\", \n    x = \"BDI-II\", \n    y = \"Densità\"\n  )\n#> Warning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `after_stat(density)` instead.\n```\n\n::: {.cell-output-display}\n![](05_exploring_numeric_data_files/figure-html/unnamed-chunk-15-1.png){width=576}\n:::\n:::\n\n\n\n\n\nAnche se nel caso presente è sensato usare ampiezze diverse per gli intervalli delle classi, in generale gli istogrammi si costruiscono utilizzando intervalli riportati sulle ascisse con un'ampiezza uguale. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = bdi)) +\n  geom_histogram(\n    aes(y = ..density..),\n    alpha = 0.5\n  ) +\n  labs(title = \"Istogramma delle frequenze relative\", x = \"BDI-II\", y = \"Densità\")\n#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n::: {.cell-output-display}\n![](05_exploring_numeric_data_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\n\n\n\n\n## Kernel density plot\n\nConfrontando le due figure precedenti, emerge chiaramente una limitazione dell'istogramma: la sua forma dipende dall'arbitrarietà con cui vengono scelti il numero e l'ampiezza delle classi, rendendo difficile interpretare correttamente la distribuzione dei dati.\n\nPer superare questa difficoltà, possiamo utilizzare una tecnica alternativa chiamata *stima della densità kernel* (KDE) -- si veda l'@sec-kde. Mentre l'istogramma utilizza barre per rappresentare i dati, la KDE crea un profilo smussato che fornisce una visione più continua e meno dipendente dall'arbitrarietà delle classi.\n\nImmaginiamo un istogramma con classi di ampiezza molto piccola, tanto da avere una curva continua invece di barre discrete. Questo è ciò che fa la KDE: smussa il profilo dell'istogramma per ottenere una rappresentazione continua dei dati. Invece di utilizzare barre, la KDE posiziona una piccola curva (detta kernel) su ogni osservazione nel dataset. Queste curve possono essere gaussiane (a forma di campana) o di altro tipo. Ogni kernel ha un'altezza e una larghezza determinate da parametri di smussamento (o bandwidth), che controllano quanto deve essere larga e alta la curva. Tutte le curve kernel vengono sommate per creare una singola curva complessiva. Questa curva rappresenta la densità dei dati, mostrando come i dati sono distribuiti lungo il range dei valori. \n\nLa curva risultante dal KDE mostra la proporzione di casi per ciascun intervallo di valori. L'area sotto la curva in un determinato intervallo rappresenta la proporzione di casi della distribuzione che ricadono in quell'intervallo. Per esempio, se un intervallo ha un'area maggiore sotto la curva rispetto ad altri, significa che in quell'intervallo c'è una maggiore concentrazione di dati. \n\nLa curva di densità ottenuta tramite KDE fornisce dunque un'idea chiara di come i dati sono distribuiti senza dipendere dall'arbitrarietà della scelta delle classi dell'istogramma. \n\nCrediamo un kernel density plot per ciascuno dei due gruppi di valori BDI-II riportati da @zetsche_2019future.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = bdi, fill = group)) +\n  geom_density(alpha = 0.5) +\n  labs(\n    title = \"Curva di densità KDE\", \n    x = \"BDI-II\", \n    y = \"Densità\"\n  )\n```\n\n::: {.cell-output-display}\n![](05_exploring_numeric_data_files/figure-html/unnamed-chunk-17-1.png){width=576}\n:::\n:::\n\n\n\n\n\n## Consigli per Creare Visualizzazioni di Dati Efficaci \n\nEcco alcuni suggerimenti per creare visualizzazioni di dati esplicative, efficaci e di qualità adatta alle presentazioni:\n\n1. **Messaggio chiaro**: Assicurati che il grafico trasmetta un messaggio chiaro e immediato (ad esempio, \"Il livello di benessere psicologico dei partecipanti aumenta nel tempo\").\n2. **Uso del colore**:\n   - Utilizza i colori in modo ponderato e con moderazione.\n   - Non eccedere nell'uso dei colori solo perché è possibile farlo.\n   - Limita l'uso a non più di cinque o sei colori in una singola figura.\n   - Verifica che le scelte cromatiche non distorcano le conclusioni della figura.\n   - Evita l'uso contemporaneo di rosso e verde nello stesso grafico, poiché queste tonalità sono difficili da distinguere per le persone daltoniche.\n3. **Guidare l'attenzione**:\n   - Utilizza dimensioni, colori e testo per guidare l'attenzione del pubblico.\n   - Evidenzia elementi particolari del grafico per enfatizzare punti chiave.\n4. **Gestione del sovraccarico visivo**:\n   - Utilizza la trasparenza per ridurre il \"sovrapplotting\" (che si verifica quando ci sono molti elementi sovrapposti nel grafico, come punti o linee, rendendo difficile individuare i pattern).\n   - Questa tecnica è particolarmente utile quando si visualizza una grande quantità di dati.\n   - Se il dataset è molto ampio e l'aggiunta di trasparenza non è sufficiente, considera la visualizzazione di un sottocampione dei dati (un campione casuale di punti dati, scelto *senza sostituzione*). Questa tecnica è nota come **sottocampionamento**.\n5. **Elementi testuali**:\n   - I titoli, le etichette degli assi e il testo delle legende devono essere chiari e facilmente comprensibili.\n   - Gli elementi della legenda dovrebbero essere ordinati in modo logico e coerente.\n\n## Forma di una Distribuzione\n\nIn statistica, la forma di una distribuzione descrive come i dati sono distribuiti intorno ai valori centrali. Si distingue tra distribuzioni simmetriche e asimmetriche, e tra distribuzioni unimodali e multimodali. Un'illustrazione grafica è fornita nella figura seguente. Nel pannello 1, la distribuzione è unimodale con asimmetria negativa; nel pannello 2, la distribuzione è unimodale con asimmetria positiva; nel pannello 3, la distribuzione è simmetrica e unimodale; nel pannello 4, la distribuzione è bimodale.\n\n![Distribuzioni](../../figures/shape_distribution.png){width=\"60%\"}\n\nIl grafico della densità di kernel (Kernel Density Plot) dei valori BDI-II nel campione di @zetsche_2019future è bimodale. Questo indica che le osservazioni della distribuzione si raggruppano in due cluster distinti: un gruppo di osservazioni tende ad avere valori BDI-II bassi, mentre l'altro gruppo tende ad avere valori BDI-II alti. Questi due cluster di osservazioni corrispondono al gruppo di controllo e al gruppo clinico nel campione di dati esaminato da @zetsche_2019future.\n\n## Indici di posizione\n\n### Quantili\n\nLa distribuzione dei valori BDI-II di @zetsche_2019future può essere sintetizzata attraverso l'uso dei quantili, che sono valori caratteristici che suddividono i dati in parti ugualmente numerose. I quartili sono tre quantili specifici: il primo quartile, $q_1$, divide i dati in due parti, lasciando a sinistra il 25% del campione; il secondo quartile, $q_2$, corrisponde alla mediana e divide i dati in due parti uguali; il terzo quartile lascia a sinistra il 75% del campione.\n\nInoltre, ci sono altri indici di posizione chiamati decili e percentili che suddividono i dati in parti di dimensioni uguali a 10% e 1%, rispettivamente.\n\nPer calcolare i quantili, i dati vengono prima ordinati in modo crescente e poi viene determinato il valore di $np$, dove $n$ è la dimensione del campione e $p$ è l'ordine del quantile. Se $np$ non è un intero, il valore del quantile corrisponde al valore del dato che si trova alla posizione successiva alla parte intera di $np$. Se $np$ è un intero, il valore del quantile corrisponde alla media dei dati nelle posizioni $k$ e $k+1$, dove $k$ è la parte intera di $np$.\n\nGli indici di posizione possono essere utilizzati per creare un box-plot, una rappresentazione grafica della distribuzione dei dati che è molto popolare e può essere utilizzata in alternativa ad un istogramma.\n\nAd esempio, per calcolare la mediana della distribuzione dei nove soggetti con un unico episodio di depressione maggiore del campione clinico di @zetsche_2019future, si determina il valore di $np = 9 \\cdot 0.5 = 4.5$, che non è un intero. Pertanto, il valore del secondo quartile è pari al valore del dato che si trova alla posizione successiva alla parte intera di $np$, ovvero $q_2 = x_{4 + 1} = 27$. Per calcolare il quantile di ordine $2/3$, si determina il valore di $np = 9 \\cdot 2/3 = 6$, che è un intero. Quindi, il valore del quantile corrisponde alla media dei dati nelle posizioni $6$ e $7$, ovvero $q_{\\frac{2}{3}} = \\frac{1}{2} (x_{6} + x_{7}) = \\frac{1}{2} (33 + 33) = 33$.\n\nUsiamo `quantile()` per trovare la soluzione dell'esercizio precedente.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(19, 26, 27, 28, 28, 33, 33, 41, 43)\nquantile(x, 2 / 3)\n#> 66.66667% \n#>        33\n```\n:::\n\n\n\n\n\n## Mostrare i dati\n\n### Diagramma a scatola\n\nIl box plot è uno strumento grafico che visualizza la dispersione di una distribuzione. Per creare un box plot, si disegna un rettangolo (la \"scatola\") di altezza arbitraria, basato sulla distanza interquartile (IQR), che corrisponde alla differenza tra il terzo quartile ($q_{0.75}$) e il primo quartile ($q_{0.25}$). La mediana ($q_{0.5}$) è rappresentata da una linea all'interno del rettangolo.\n\nAi lati della scatola, vengono tracciati due segmenti di retta, detti \"baffi\", che rappresentano i valori adiacenti inferiore e superiore. Il valore adiacente inferiore è il valore più basso tra le osservazioni che è maggiore o uguale al primo quartile meno 1.5 volte la distanza interquartile. Il valore adiacente superiore è il valore più alto tra le osservazioni che è minore o uguale al terzo quartile più 1.5 volte la distanza interquartile.\n\nSe ci sono dei valori che cadono al di fuori dei valori adiacenti, vengono chiamati \"valori anomali\" e sono rappresentati individualmente nel box plot per evidenziare la loro presenza e posizione. In questo modo, il box plot fornisce una rappresentazione visiva della distribuzione dei dati, permettendo di individuare facilmente eventuali valori anomali e di comprendere la dispersione dei dati.\n\n![](../../figures/boxplot.png){width=\"80%\"}\n\nUtilizziamo un box-plot per rappresentare graficamente la distribuzione dei punteggi BDI-II nel gruppo dei pazienti e nel gruppo di controllo.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = group, y = bdi)) +\n  geom_boxplot() +\n  labs(\n    title = \"Box plot per gruppo\", \n    x = \"Gruppo\", \n    y = \"BDI-II\"\n  )\n```\n\n::: {.cell-output-display}\n![](05_exploring_numeric_data_files/figure-html/unnamed-chunk-19-1.png){width=576}\n:::\n:::\n\n\n\n\n\nUn risultato migliore si ottiene utilizzando un grafico a violino (*violin plot*) e includendo anche i dati grezzi.\n\n### Grafico a Violino\n\nI grafici a violino combinano le caratteristiche dei box plot e dei grafici di densità di kernel (KDE plot) per offrire una rappresentazione più dettagliata dei dati. A questi grafici vengono sovrapposti i dati grezzi, fornendo una visione completa della distribuzione e delle caratteristiche dei dati.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = group, y = bdi, fill = group)) +\n  geom_violin(alpha = 0.5) +\n  geom_dotplot(\n    binaxis = \"y\",\n    stackdir = \"center\",\n    dotsize = 0.5,\n    fill = 1\n  ) +\n  labs(\n    title = \"Violin plot con overlay dei punti grezzi\",\n    x = \"Gruppo\",\n    y = \"BDI-II\"\n  )\n#> Bin width defaults to 1/30 of the range of the data. Pick better value with\n#> `binwidth`.\n```\n\n::: {.cell-output-display}\n![](05_exploring_numeric_data_files/figure-html/unnamed-chunk-20-1.png){width=576}\n:::\n:::\n\n\n\n\n\n### Grafico Beeswarm\n\nIl pacchetto *{ggbeeswarm}* include una funzione chiamata `geom_beeswarm`, che può essere utilizzata per creare un grafico beeswarm in ggplot2.\n\nUn grafico beeswarm è una variazione del grafico a punti che disperde i dati in modo che non si sovrappongano, rendendo visibili tutti i singoli punti dati. Questo tipo di visualizzazione è particolarmente utile quando si desidera esaminare la distribuzione e la densità di un set di dati, senza ricorrere all'uso di barre d'errore o di scatole e baffi (boxplot), mantenendo un'alta leggibilità anche quando i set di dati sono densi.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = group, y = bdi, color = group)) +\n  geom_beeswarm(cex = 3) +\n  labs(\n    title = \"Violin plot con overlay dei punti grezzi\",\n    x = \"Gruppo\",\n    y = \"BDI-II\"\n  )\n```\n\n::: {.cell-output-display}\n![](05_exploring_numeric_data_files/figure-html/unnamed-chunk-21-1.png){width=576}\n:::\n:::\n\n\n\n\n\n## Riflessioni Conclusive\n\nAbbiamo esplorato diverse tecniche per sintetizzare e visualizzare i dati, includendo distribuzioni di frequenze, istogrammi e grafici di densità. Questi strumenti sono essenziali per comprendere meglio i dati e presentare risultati in modo chiaro e informativo.\n\n## Informazioni sull'Ambiente di Sviluppo {.unnumbered}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.4.2 (2024-10-31)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.2\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] ggbeeswarm_0.7.2  viridis_0.6.5     viridisLite_0.4.2 gridExtra_2.3    \n#>  [5] patchwork_1.3.0   bayesplot_1.11.1  psych_2.4.6.26    scales_1.3.0     \n#>  [9] markdown_1.13     knitr_1.49        lubridate_1.9.4   forcats_1.0.0    \n#> [13] stringr_1.5.1     dplyr_1.1.4       purrr_1.0.2       readr_2.1.5      \n#> [17] tidyr_1.3.1       tibble_3.2.1      ggplot2_3.5.1     tidyverse_2.0.0  \n#> [21] rio_1.2.3         here_1.0.1       \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] utf8_1.2.4        generics_0.1.3    stringi_1.8.4     lattice_0.22-6   \n#>  [5] hms_1.1.3         digest_0.6.37     magrittr_2.0.3    evaluate_1.0.1   \n#>  [9] grid_4.4.2        timechange_0.3.0  fastmap_1.2.0     R.oo_1.27.0      \n#> [13] rprojroot_2.0.4   jsonlite_1.8.9    R.utils_2.12.3    fansi_1.0.6      \n#> [17] mnormt_2.1.1      cli_3.6.3         rlang_1.1.4       R.methodsS3_1.8.2\n#> [21] munsell_0.5.1     withr_3.0.2       tools_4.4.2       parallel_4.4.2   \n#> [25] tzdb_0.4.0        colorspace_2.1-1  pacman_0.5.1      vctrs_0.6.5      \n#> [29] R6_2.5.1          lifecycle_1.0.4   htmlwidgets_1.6.4 vipor_0.4.7      \n#> [33] beeswarm_0.4.0    pkgconfig_2.0.3   pillar_1.9.0      gtable_0.3.6     \n#> [37] data.table_1.16.4 glue_1.8.0        xfun_0.49         tidyselect_1.2.1 \n#> [41] farver_2.1.2      htmltools_0.5.8.1 nlme_3.1-166      labeling_0.4.3   \n#> [45] rmarkdown_2.29    compiler_4.4.2\n```\n:::\n\n\n\n\n\n## Bibliografia {.unnumbered}\n\n",
    "supporting": [
      "05_exploring_numeric_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}